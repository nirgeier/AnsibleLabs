{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"List of Labs","text":"Lab Summary Build Status Lab 000 - Setup Setup lab environment with Ansible controller and Linux servers using Docker containers. Lab 001 - Verify Ansible configuration Verify Ansible configuration by creating and testing ansible.cfg, inventory, and ssh.config files. Lab 002 - No Inventory Example Demonstrate the importance of inventory by showing behavior without it and then configuring one. Lab 003 - Commands &amp; Modules Learn about Ansible modules, focusing on the ping module and ad-hoc commands. Lab 004 - Playbooks Introduction to Ansible playbooks, their structure, and basic usage. Lab 005 - Facts Learn about Ansible facts, how to gather and use them in playbooks. Lab 006 - Git Hands-on lab to create a playbook for installing Git and cloning repositories. Lab 007 - Create User Hands-on lab to create a playbook for creating users on remote systems. Lab 008 - Challenges Challenge lab combining user creation and Git operations. \u2014 Lab 009 - Roles Learn about Ansible roles, their structure, and how to create and use them. Lab 010 - Loops and Conditionals Learn about loops and conditional statements in Ansible playbooks. Lab 011 - Jinja2 Templating Learn about Jinja2 templating for dynamic configuration files in Ansible."},{"location":"welcome/","title":"Start Here","text":"<p>Getting Started Tip</p> <p>Choose the preferred way to run the labs. If you encounter any issues, please contact your instructor.</p> <ul> <li> <p> <pre><code>cd 000-setup &amp;&amp; docker-compose up -d\n</code></pre></p> </li> <li> <p> Launch on KillerCoda</p> </li> </ul>"},{"location":"welcome/#ansible-labs","title":"Ansible Labs","text":""},{"location":"welcome/#intro","title":"Intro","text":"<ul> <li>This tutorial is for teaching Ansible through hands-on labs designed as practical exercises.</li> <li>Each lab is packaged in its own folder and includes the files, playbooks, and assets required to complete the lab.</li> <li>Every lab folder includes a <code>README</code> that describes the lab\u2019s objectives, tasks, and how to verify the solution.</li> <li>The Ansible Labs are a series of Ansible automation exercises designed to teach players Ansible skills &amp; features.</li> <li>The inspiration for this project is to provide practical learning experiences for Ansible.</li> </ul>"},{"location":"welcome/#pre-requirements","title":"Pre-Requirements","text":"<ul> <li>This tutorial will test your <code>Ansible</code> and <code>Linux</code> skills.</li> <li>You should be familiar with the following topics:<ul> <li>Basic Linux commands</li> <li>Linux File system navigation</li> <li>Basic knowledge of <code>Docker</code> (if you choose to run it with Docker)</li> <li>Basic knowledge of YAML</li> </ul> </li> <li>For advanced Labs: <ul> <li><code>Ansible</code> basics (<code>inventory</code>, <code>playbooks</code>, <code>modules</code>)</li> </ul> </li> </ul>"},{"location":"welcome/#usage","title":"Usage","text":"<ul> <li>There are several ways to run the Ansible Labs. </li> <li>Choose the method that works best for you.<ul> <li> Killercoda  (Recommended)</li> <li>\ud83d\udc33 Docker</li> <li>\ud83d\udcdc From Source</li> <li> Using Google Cloud Shell</li> </ul> </li> </ul>  Killercoda  (Recommended)\ud83d\udc33 Docker\ud83d\udcdc From Source Using Google Cloud Shell <ul> <li>The easiest way to get started with the labs</li> <li>Learn Ansible in your browser without any local installation</li> </ul> <p>\ud83c\udf10 Launch on Killercoda</p> <p>Benefits:</p> <ul> <li>No installation required</li> <li>Pre-configured environment</li> <li>Works on any device with a web browser</li> <li>All tools pre-installed</li> </ul> <p>Using Docker is the easiest way to get started locally with the labs:</p> <pre><code># Change to the Labs directory\ncd Labs/000-setup\n\n# Run the setup lab using Docker Compose\ndocker-compose up -d\n</code></pre> <p>Prerequisites:</p> <ul> <li>Docker and Docker Compose installed on your system</li> <li>No additional setup required</li> </ul> <p>For those who prefer to run it directly on their machine:</p> <p><pre><code># Clone the repository\ngit clone https://github.com/nirgeier/AnsibleLabs.git\n# Change to the Labs directory\ncd AnsibleLabs/Labs\n# Start with the setup lab\ncd 000-setup\n# Follow the instructions in the README of each lab\ncat README.md\n</code></pre> Prerequisites:</p> <ul> <li>Ansible installed on your system</li> <li>A Unix-like operating system (Linux, macOS, or Windows with WSL)</li> <li>Basic command-line tools</li> </ul> <ul> <li>Google Cloud Shell provides a free, browser-based environment with all necessary tools pre-installed.</li> <li>Click on the <code>Open in Google Cloud Shell</code> button below:</li> </ul> <p></p> <ul> <li>The repository will automatically be cloned into a free Cloud instance.</li> <li>Use CTRL + click to open it in a new window.</li> <li>Follow the instructions in the README of each lab.</li> </ul> <p>Benefits:</p> <ul> <li>No local installation required</li> <li>Pre-configured environment</li> <li>Works on any device with a web browser</li> <li>All tools pre-installed</li> <li>Free tier available</li> </ul> <p>Lab Breakdown</p> <ul> <li>If you choose to run the labs locally using Docker or From Source, follow the steps below to set up your environment.</li> <li>Make sure you have the necessary tools installed.</li> <li>Follow the instructions in the README of each lab.</li> <li>Review the Dockerfile(s) and docker-compose.yml for container configurations.</li> </ul>"},{"location":"welcome/#02-build-from-source","title":"02. Build from source","text":"<ul> <li>Clone the git repo: <pre><code>git clone https://github.com/nirgeier/AnsibleLabs.git\n</code></pre></li> <li>Navigate to the Labs directory: <pre><code>cd AnsibleLabs/Labs/000-setup\n</code></pre></li> <li> <p>Run the setup script: <pre><code>./_setup.sh\n</code></pre>     Setup scripts breakdown:</p> Script Content \ud83d\uddde\ufe0f <code>00-build-containers.sh</code> \ud83d\udcd2 Init the shared folders \ud83d\udc33 Build the container(s) \ud83d\uddde\ufe0f <code>01-init-servers.sh</code> \u23ef Initialize the containers \ud83d\udd10 Extract the ssh certificates \u2713 verify that the ssh service is running in the containers \ud83d\uddde\ufe0f <code>02-init-ansible.sh</code> \ud83d\ude80 Initialize the ansible files \ud83d\udcda <code>ansible.cfg</code> \ud83d\udcda <code>ssh.config</code> \ud83d\udcda <code>inventory</code> </li> <li> <p>The lab contains a <code>docker-compose</code> file alongside a Dockerfile.</p> </li> <li>The containers are based on Ubuntu OS and are published on <code>DockerHub</code> as well.</li> <li>Build the demo containers by running: <pre><code>docker-compose up -d\n</code></pre></li> <li>The docker-compose will create <code>ansible-controller</code> which will server as our controller to execute ansible playbooks on our demo servers defined by the names <code>linux-server-X</code></li> </ul> <p>Labs containers</p> Container Content \ud83d\udc33  <code>ansible-controller</code> Linux container with ansible installed \ud83d\udc33  <code>linux-server-1</code> Linux container with ssh only (no ansible installed) \ud83d\udc33  <code>linux-server-2</code> Linux container with ssh only (no ansible installed) \ud83d\udc33   <code>linux-server-3</code> Linux container with ssh only (no ansible installed) <ul> <li>For the demo we will also need a shared folder(s) where the certificates and the configuration will be stored</li> <li>The shared folder(s) will be mounted into the containers</li> <li>The containers will have access to the shared folder(s) for reading and writing files</li> <li>The shared folder(s) will be used to store the Ansible playbooks and inventory files</li> <li>The shared folder(s) will be mounted at <code>/labs-scripts</code> in the containers</li> </ul> <ul> <li>Ensure you have the necessary permissions to run Docker commands or Ansible playbooks on your system.</li> <li>Enjoy, and don\u2019t forget to star the project on GitHub!</li> </ul>"},{"location":"welcome/#preface","title":"Preface","text":""},{"location":"welcome/#what-is-ansible","title":"What is Ansible?","text":"<ul> <li><code>Ansible</code> is an open-source automation tool for IT tasks such as configuration management, application deployment, and task automation. </li> <li><code>Ansible</code> is <code>Configuration Management</code> tool which manage the <code>state</code> of our servers, install the required packages and tools.</li> <li>Other optional use cases can be  <code>deployments</code>, <code>Provisioning new servers</code></li> <li>The most powerful feature of <code>Ansible</code> is the ability to manage huge scale of servers regardless of their infrastructure (on prem, cloud, vm etc)</li> <li><code>Ansible</code> uses SSH to connect to servers and execute tasks defined in YAML playbooks, making it agentless and easy to use. </li> <li><code>Ansible</code> is widely used for managing infrastructure, ensuring consistency, and automating repetitive processes across various environments (on-premises, cloud, VMs, etc.).</li> </ul>"},{"location":"welcome/#how-ansible-works","title":"How Ansible Works","text":"<ul> <li>Ansible is an <code>agentless tool</code>.</li> <li>Ansible uses <code>ssh</code> for <code>pulling modules</code> and for managing the nodes</li> <li>Ansible is based upon <code>YAML</code> </li> <li>An <code>Ansible playbook</code> is a file that contains a set of instructions that Ansible can use to automate tasks on remote hosts.</li> <li><code>Playbooks</code> are written in <code>YAML</code>, a human-readable markup language. A playbook typically consists of one or more <code>plays</code>, a collection of tasks run in sequence.</li> </ul>"},{"location":"welcome/#how-ansible-playbooks-work","title":"How Ansible Playbooks Work","text":"<ul> <li>Here\u2019s a brief overview of how <code>Ansible playbooks</code> work:</li> </ul> <ul> <li> </li> <li> </li> <li> </li> <li> </li> </ul> <ul> <li>Playbooks are one of the core features of Ansible and tell Ansible what to execute.</li> <li>They are used in complex scenarios.</li> <li>They serve as frameworks of pre-written code that developers can use ad-hoc or as a starting template.</li> <li>They can be saved, shared, or reused indefinitely, making it easier for IT teams to codify operational knowledge and ensure that the same actions are performed consistently.</li> </ul>"},{"location":"welcome/#playbook-structure","title":"Playbook Structure","text":"<ul> <li> <p>A <code>playbook</code> is composed of one or more <code>plays</code> in an ordered list. </p> </li> <li> <p>Each <code>play</code> executes part of the overall goal of the <code>playbook</code>, running one or more tasks. </p> </li> <li>Each task calls an <code>Ansible</code> module.</li> </ul>"},{"location":"welcome/#playbook-execution","title":"Playbook Execution","text":"<ul> <li> <p>A <code>playbook</code> runs in order from top to bottom.</p> </li> <li> <p>Within each <code>play</code>, tasks also run in order from top to bottom.</p> </li> <li> <p>Playbooks with multiple <code>plays</code> can orchestrate multi-machine deployments.</p> </li> </ul>"},{"location":"welcome/#task-execution","title":"Task Execution","text":"<ul> <li> <p><code>Tasks</code> are executed by <code>modules</code>, each of which performs a specific task in a playbook.</p> </li> <li> <p>There are thousands of <code>Ansible modules</code> that perform all kinds of IT tasks.</p> </li> </ul>"},{"location":"welcome/#reusability","title":"Reusability","text":"<ul> <li> <p><code>Playbooks</code> offer a repeatable, reusable, simple configuration management and multi-machine deployment system.</p> </li> <li> <p>If you need to execute a <code>task</code> with <code>Ansible</code> more than once, write a <code>playbook</code> and put it under source control.</p> </li> </ul>"},{"location":"000-setup/","title":"000 Setup","text":""},{"location":"000-setup/#lab-000-setup","title":"Lab 000 - Setup","text":"<ul> <li>In this lab we will define and build docker containers which will be used in the next labs.</li> <li>The lab structure consists of an Ansible controller &amp; 3 Linux servers, all set inside docker containers.</li> </ul>"},{"location":"000-setup/#01-usage","title":"01. Usage","text":"<ul> <li>There are several ways to run the Ansible Labs. </li> <li>Choose the method that works best for you.<ul> <li> Killercoda  (Recommended)</li> <li>\ud83d\udc33 Docker</li> <li>\ud83d\udcdc From Source</li> <li> Using Google Cloud Shell</li> </ul> </li> </ul>  Killercoda  (Recommended)\ud83d\udc33 Docker\ud83d\udcdc From Source Using Google Cloud Shell <ul> <li>The easiest way to get started with the labs</li> <li>Learn Ansible in your browser without any local installation</li> </ul> <p>\ud83c\udf10 Launch on Killercoda</p> <p>Benefits:</p> <ul> <li>No installation required</li> <li>Pre-configured environment</li> <li>Works on any device with a web browser</li> <li>All tools pre-installed</li> </ul> <p>Using Docker is the easiest way to get started locally with the labs:</p> <pre><code># Change to the Labs directory\ncd Labs/000-setup\n\n# Run the setup lab using Docker Compose\ndocker-compose up -d\n</code></pre> <p>Prerequisites:</p> <ul> <li>Docker and Docker Compose installed on your system</li> <li>No additional setup required</li> </ul> <p>For those who prefer to run it directly on their machine:</p> <p><pre><code># Clone the repository\ngit clone https://github.com/nirgeier/AnsibleLabs.git\n# Change to the Labs directory\ncd AnsibleLabs/Labs\n# Start with the setup lab\ncd 000-setup\n# Follow the instructions in the README of each lab\ncat README.md\n</code></pre> Prerequisites:</p> <ul> <li>Ansible installed on your system</li> <li>A Unix-like operating system (Linux, macOS, or Windows with WSL)</li> <li>Basic command-line tools</li> </ul> <ul> <li>Google Cloud Shell provides a free, browser-based environment with all necessary tools pre-installed.</li> <li>Click on the <code>Open in Google Cloud Shell</code> button below:</li> </ul> <p></p> <ul> <li>The repository will automatically be cloned into a free Cloud instance.</li> <li>Use CTRL + click to open it in a new window.</li> <li>Follow the instructions in the README of each lab.</li> </ul> <p>Benefits:</p> <ul> <li>No local installation required</li> <li>Pre-configured environment</li> <li>Works on any device with a web browser</li> <li>All tools pre-installed</li> <li>Free tier available</li> </ul> <p>Lab Breakdown</p> <ul> <li>If you choose to run the labs locally using Docker or From Source, follow the steps below to set up your environment.</li> <li>Make sure you have the necessary tools installed.</li> <li>Follow the instructions in the README of each lab.</li> <li>Review the Dockerfile(s) and docker-compose.yml for container configurations.</li> </ul>"},{"location":"000-setup/#02-build-from-source","title":"02. Build from source","text":"<ul> <li>Clone the git repo: <pre><code>git clone https://github.com/nirgeier/AnsibleLabs.git\n</code></pre></li> <li>Navigate to the Labs directory: <pre><code>cd AnsibleLabs/Labs/000-setup\n</code></pre></li> <li> <p>Run the setup script: <pre><code>./_setup.sh\n</code></pre>     Setup scripts breakdown:</p> Script Content \ud83d\uddde\ufe0f <code>00-build-containers.sh</code> \ud83d\udcd2 Init the shared folders \ud83d\udc33 Build the container(s) \ud83d\uddde\ufe0f <code>01-init-servers.sh</code> \u23ef Initialize the containers \ud83d\udd10 Extract the ssh certificates \u2713 verify that the ssh service is running in the containers \ud83d\uddde\ufe0f <code>02-init-ansible.sh</code> \ud83d\ude80 Initialize the ansible files \ud83d\udcda <code>ansible.cfg</code> \ud83d\udcda <code>ssh.config</code> \ud83d\udcda <code>inventory</code> </li> <li> <p>The lab contains a <code>docker-compose</code> file alongside a Dockerfile.</p> </li> <li>The containers are based on Ubuntu OS and are published on <code>DockerHub</code> as well.</li> <li>Build the demo containers by running: <pre><code>docker-compose up -d\n</code></pre></li> <li>The docker-compose will create <code>ansible-controller</code> which will server as our controller to execute ansible playbooks on our demo servers defined by the names <code>linux-server-X</code></li> </ul> <p>Labs containers</p> Container Content \ud83d\udc33  <code>ansible-controller</code> Linux container with ansible installed \ud83d\udc33  <code>linux-server-1</code> Linux container with ssh only (no ansible installed) \ud83d\udc33  <code>linux-server-2</code> Linux container with ssh only (no ansible installed) \ud83d\udc33   <code>linux-server-3</code> Linux container with ssh only (no ansible installed) <ul> <li>For the demo we will also need a shared folder(s) where the certificates and the configuration will be stored</li> <li>The shared folder(s) will be mounted into the containers</li> <li>The containers will have access to the shared folder(s) for reading and writing files</li> <li>The shared folder(s) will be used to store the Ansible playbooks and inventory files</li> <li>The shared folder(s) will be mounted at <code>/labs-scripts</code> in the containers</li> </ul>"},{"location":"000-setup/#03-core-concepts","title":"03. Core concepts","text":"<ul> <li>Create <code>Ansible Controller</code> container, which will be used to manage the other containers</li> <li><code>SSH Keys</code> - The SSH keys will be generated and mounted into the containers</li> <li>Initialize servers: Set up runtime directories, start demo containers via <code>Docker Compose</code>, verify <code>Ansible</code> installation, extract <code>SSH keys</code> from servers, configure known hosts, check SSH services, and test SSH connections to each Linux server</li> </ul>"},{"location":"000-setup/#04-verify-containers","title":"04. Verify containers","text":"<pre><code>$ docker ps -a\n\n\n# Expected output\n\nIMAGE                       PORTS                                                                  NAMES\n---------------------------------------------------------------------------------------------------------------------\nnirgeier/ansible-controller 22/tcp                                                                 ansible-controller\nnirgeier/linux-server       0.0.0.0:3001-&gt;22/tcp, 0.0.0.0:5001-&gt;5000/tcp, 0.0.0.0:8081-&gt;8080/tcp   linux-server-1\nnirgeier/linux-server       0.0.0.0:3002-&gt;22/tcp, 0.0.0.0:5002-&gt;5000/tcp, 0.0.0.0:8082-&gt;8080/tcp   linux-server-2\nnirgeier/linux-server       0.0.0.0:3003-&gt;22/tcp, 0.0.0.0:5003-&gt;5000/tcp, 0.0.0.0:8083-&gt;8080/tcp   linux-server-3\n</code></pre>"},{"location":"000-setup/#05-next-steps","title":"05. Next steps","text":"<ul> <li>Proceed to Lab 001 - Verify Ansible configuration to start using Ansible with the configured environment.</li> <li>Don\u2019t forget to check the logs for any errors or issues during the setup process.</li> <li>If you encounter any problems, refer to the troubleshooting section or open an issue on the GitHub repository.</li> <li>Enjoy learning Ansible!</li> </ul>"},{"location":"000-setup/usage/","title":"Usage","text":"<ul> <li>There are several ways to run the Ansible Labs. </li> <li>Choose the method that works best for you.<ul> <li> Killercoda  (Recommended)</li> <li>\ud83d\udc33 Docker</li> <li>\ud83d\udcdc From Source</li> <li> Using Google Cloud Shell</li> </ul> </li> </ul>  Killercoda  (Recommended)\ud83d\udc33 Docker\ud83d\udcdc From Source Using Google Cloud Shell <ul> <li>The easiest way to get started with the labs</li> <li>Learn Ansible in your browser without any local installation</li> </ul> <p>\ud83c\udf10 Launch on Killercoda</p> <p>Benefits:</p> <ul> <li>No installation required</li> <li>Pre-configured environment</li> <li>Works on any device with a web browser</li> <li>All tools pre-installed</li> </ul> <p>Using Docker is the easiest way to get started locally with the labs:</p> <pre><code># Change to the Labs directory\ncd Labs/000-setup\n\n# Run the setup lab using Docker Compose\ndocker-compose up -d\n</code></pre> <p>Prerequisites:</p> <ul> <li>Docker and Docker Compose installed on your system</li> <li>No additional setup required</li> </ul> <p>For those who prefer to run it directly on their machine:</p> <p><pre><code># Clone the repository\ngit clone https://github.com/nirgeier/AnsibleLabs.git\n# Change to the Labs directory\ncd AnsibleLabs/Labs\n# Start with the setup lab\ncd 000-setup\n# Follow the instructions in the README of each lab\ncat README.md\n</code></pre> Prerequisites:</p> <ul> <li>Ansible installed on your system</li> <li>A Unix-like operating system (Linux, macOS, or Windows with WSL)</li> <li>Basic command-line tools</li> </ul> <ul> <li>Google Cloud Shell provides a free, browser-based environment with all necessary tools pre-installed.</li> <li>Click on the <code>Open in Google Cloud Shell</code> button below:</li> </ul> <p></p> <ul> <li>The repository will automatically be cloned into a free Cloud instance.</li> <li>Use CTRL + click to open it in a new window.</li> <li>Follow the instructions in the README of each lab.</li> </ul> <p>Benefits:</p> <ul> <li>No local installation required</li> <li>Pre-configured environment</li> <li>Works on any device with a web browser</li> <li>All tools pre-installed</li> <li>Free tier available</li> </ul> <p>Lab Breakdown</p> <ul> <li>If you choose to run the labs locally using Docker or From Source, follow the steps below to set up your environment.</li> <li>Make sure you have the necessary tools installed.</li> <li>Follow the instructions in the README of each lab.</li> <li>Review the Dockerfile(s) and docker-compose.yml for container configurations.</li> </ul>"},{"location":"000-setup/usage/#02-build-from-source","title":"02. Build from source","text":"<ul> <li>Clone the git repo: <pre><code>git clone https://github.com/nirgeier/AnsibleLabs.git\n</code></pre></li> <li>Navigate to the Labs directory: <pre><code>cd AnsibleLabs/Labs/000-setup\n</code></pre></li> <li> <p>Run the setup script: <pre><code>./_setup.sh\n</code></pre>     Setup scripts breakdown:</p> Script Content \ud83d\uddde\ufe0f <code>00-build-containers.sh</code> \ud83d\udcd2 Init the shared folders \ud83d\udc33 Build the container(s) \ud83d\uddde\ufe0f <code>01-init-servers.sh</code> \u23ef Initialize the containers \ud83d\udd10 Extract the ssh certificates \u2713 verify that the ssh service is running in the containers \ud83d\uddde\ufe0f <code>02-init-ansible.sh</code> \ud83d\ude80 Initialize the ansible files \ud83d\udcda <code>ansible.cfg</code> \ud83d\udcda <code>ssh.config</code> \ud83d\udcda <code>inventory</code> </li> <li> <p>The lab contains a <code>docker-compose</code> file alongside a Dockerfile.</p> </li> <li>The containers are based on Ubuntu OS and are published on <code>DockerHub</code> as well.</li> <li>Build the demo containers by running: <pre><code>docker-compose up -d\n</code></pre></li> <li>The docker-compose will create <code>ansible-controller</code> which will server as our controller to execute ansible playbooks on our demo servers defined by the names <code>linux-server-X</code></li> </ul> <p>Labs containers</p> Container Content \ud83d\udc33  <code>ansible-controller</code> Linux container with ansible installed \ud83d\udc33  <code>linux-server-1</code> Linux container with ssh only (no ansible installed) \ud83d\udc33  <code>linux-server-2</code> Linux container with ssh only (no ansible installed) \ud83d\udc33   <code>linux-server-3</code> Linux container with ssh only (no ansible installed) <ul> <li>For the demo we will also need a shared folder(s) where the certificates and the configuration will be stored</li> <li>The shared folder(s) will be mounted into the containers</li> <li>The containers will have access to the shared folder(s) for reading and writing files</li> <li>The shared folder(s) will be used to store the Ansible playbooks and inventory files</li> <li>The shared folder(s) will be mounted at <code>/labs-scripts</code> in the containers</li> </ul>"},{"location":"001-verify-ansible/","title":"001 Verify Ansible","text":""},{"location":"001-verify-ansible/#lab-001-verify-ansible-configuration","title":"Lab 001 - Verify Ansible configuration","text":"<ul> <li>In this lab we will create the Ansible configuration and verify that it is configured correctly.</li> <li>This lab is based upon the previous lab and its <code>docker-compose</code>.</li> <li>In this lab we will learn how to use:<ul> <li><code>ansible.cfg</code></li> <li><code>inventory</code></li> <li><code>ssh.config</code></li> </ul> </li> </ul>"},{"location":"001-verify-ansible/#pre-requirements","title":"Pre-Requirements","text":"<ul> <li>Complete the previous lab in order to have the <code>Ansible</code> controller and the <code>Linux</code> servers up and running.</li> </ul>"},{"location":"001-verify-ansible/#01-create-configuration-files","title":"01. Create configuration files","text":"<p>IMPORTANT!</p> <ul> <li>In this lab we will be placing the files under the <code>/labs-scripts</code> directory.  </li> <li>The directory is mounted to our docker container(s) under the <code>&lt;PROJECT_ROOT&gt;/runtime</code> directory.  </li> <li>You are encouraged to review  the <code>docker-compose.yaml</code> file throughout the lab session. </li> </ul>"},{"location":"001-verify-ansible/#02-about-ansiblecfg-file","title":"02. About <code>ansible.cfg</code> file","text":"<ul> <li>What is <code>ansible.cfg</code> ?<ul> <li>The <code>ansible.cfg</code> file is an INI-like configuration file used to define various settings and parameters that influence how Ansible operates. </li> <li>It allows users to customize Ansible\u2019s behavior, such as specifying inventory locations, default module settings, connection options, and more.</li> <li>The <code>ansible.cfg</code> file can be placed in several locations, and Ansible will search for it in a specific order.</li> <li>The configuration file is divided into sections, each containing various customizable parameters that control different aspects of Ansible\u2019s functionality.</li> <li>Below we will create the <code>ansible.cfg</code> file, the <code>ssh.config</code> file and the <code>inventory</code> file.</li> </ul> </li> </ul>"},{"location":"001-verify-ansible/#03-ansiblecfg-locations","title":"03. <code>ansible.cfg</code> locations:","text":"<ul> <li>Reference: Official Ansible documentation: - Ansible Configuration Settings</li> <li>Ansible searches <code>ansible.cfg</code> in a specific order. </li> <li>The first file it finds will be used while ignoring the rest.</li> <li> <p>Ansible will search for the configuration file in the following order: </p> Search resource Description <code>ANSIBLE_CONFIG</code> environment variable if set <code>ansible.cfg</code> In the current directory <code>~/.ansible.cfg</code> Under the home directory <code>/etc/ansible/ansible.cfg</code> OS common path </li> <li> <p>In this exercise the environment variable <code>ANSIBLE_CONFIG</code> is set in the docker container path <code>/labs-scripts/.ansible.cfg</code></p> </li> </ul>"},{"location":"001-verify-ansible/#04-ansiblecfg-structure","title":"04. <code>ansible.cfg</code> structure:","text":"<ul> <li> <p>The <code>ansible.cfg</code> file is divided into sections, each containing various customizable parameters.</p> </li> <li> <p>Main <code>ansible.cfg</code> settings:</p> </li> </ul> Setting Description Ansible Docs [callback_plugins] Specifies directories for callback plugins that customize output or trigger actions. Docs [connection] Defines general connection settings that apply to all connection types. Docs [defaults] Contains general settings for Ansible such as inventory location, verbosity, and log settings. Docs [diff] Controls whether Ansible shows differences when applying configurations. Docs [galaxy] Configures settings for Ansible Galaxy, a hub for sharing roles and collections. Docs [inventory] Defines options related to inventory parsing and caching. Docs [logging] Logging configuration, typically under [defaults] section using log_path. Docs [paramiko_connection] Configures settings specific to the Paramiko SSH library. Docs [privilege_escalation] Defines settings related to privilege escalation, such as sudo or become. Docs [ssh_connection] Settings for SSH connections, (timeout, control settings etc). Docs [winrm] Configures settings for Windows Remote Management (WinRM) connections. Docs"},{"location":"001-verify-ansible/#callback_plugins","title":"<code>[callback_plugins]</code>","text":"<ul> <li>The <code>[callback_plugins]</code> section specifies directories where Ansible looks for callback plugins, which can customize output or trigger actions based on playbook events.     <pre><code>[callback_plugins]\n    stdout_callback     =    yaml\n    callback_whitelist  =    timer, profile_tasks\n</code></pre></li> </ul>"},{"location":"001-verify-ansible/#connection","title":"<code>[connection]</code>","text":"<ul> <li>The <code>[connection]</code> section defines general connection settings that apply to all connection types.     <pre><code>[connection]\n    pipelining          =    True\n    control_path_dir    =    ~/.ansible/cp\n</code></pre></li> </ul>"},{"location":"001-verify-ansible/#defaults","title":"<code>[defaults]</code>","text":"<ul> <li>The <code>[defaults]</code> section contains the general settings for Ansible (such as inventory location, verbosity and log settings).</li> <li>It is the most commonly used section and is often the first place users look to customize their Ansible environment.</li> <li> <p>Here are some commonly used settings in the <code>[defaults]</code> section:</p> <ul> <li><code>ask_pass</code> - If set to true, Ansible will prompt for the SSH password.</li> <li><code>host_key_checking</code> - If set to false, Ansible will not check SSH host keys.</li> <li><code>inventory</code> - Specifies the path to the inventory file.</li> <li><code>log_path</code> - Specifies the path to the log file.</li> <li><code>remote_user</code> - Specifies the default remote user for SSH connections.</li> <li><code>timeout</code> - Specifies the timeout for SSH connections in seconds.</li> <li><code>private_key_file</code> - Specifies the path to the private key file for SSH authentication.</li> <li><code>become</code> - If set to true, privilege escalation (e.g., sudo) will be used.</li> <li><code>become_method</code> - Specifies the method to use for privilege escalation (e.g., sudo, su).</li> <li><code>become_user</code> - Specifies the user to become when using privilege escalation.</li> <li><code>retry_files_enabled</code> - If set to false, Ansible will not create retry files.</li> <li><code>gathering</code> - Specifies how facts are gathered (e.g., smart, explicit, none).</li> </ul> <pre><code>[defaults]\n    ask_pass            =    false\n    host_key_checking   =    false\n    inventory           =    /etc/ansible/hosts\n    log_path            =    /var/log/ansible.log\n    remote_user         =    ansible\n    timeout             =    30\n</code></pre> </li> </ul>"},{"location":"001-verify-ansible/#diff","title":"<code>[diff]</code>","text":"<ul> <li>Controls whether Ansible shows differences when applying configurations.</li> <li> <p>This can be useful for debugging and understanding changes.</p> <ul> <li><code>always</code> - Show differences even when the playbook is not run in check mode.</li> <li><code>context</code> - The number of lines of context to show around changes.</li> <li><code>ignore</code> - Do not show differences.</li> <li><code>diff</code> - Show a unified diff of changes.</li> <li><code>unified</code> - Show a unified diff of changes with context lines.</li> </ul> <pre><code>[diff]\n    always              =    True\n    context             =    5\n</code></pre> </li> </ul>"},{"location":"001-verify-ansible/#galaxy","title":"<code>[galaxy]</code>","text":"<ul> <li>The <code>[galaxy]</code> section configures settings for Ansible Galaxy, which is a hub for sharing and downloading Ansible roles and collections.</li> <li>This section can be used to specify custom Galaxy servers, caching options, and other related settings.</li> <li> <p>Here is an example configuration for the <code>[galaxy]</code> section:</p> <ul> <li><code>server_list</code> - Specifies the list of Galaxy servers to use.</li> <li><code>cache_dir</code> - Specifies the directory to cache downloaded roles and collections.</li> <li><code>role_file</code> - Specifies the path to the file containing role definitions.</li> <li><code>collection_file</code> - Specifies the path to the file containing collection definitions.</li> <li><code>requirements_file</code> - Specifies the path to the file containing Galaxy requirements.</li> <li><code>role_file</code> - Specifies the path to the file containing role definitions.</li> </ul> <pre><code>[galaxy]\n    server_list         =    release_galaxy\n    cache_dir           =    ~/.ansible/galaxy_cache\n</code></pre> </li> </ul>"},{"location":"001-verify-ansible/#inventory","title":"<code>[inventory]</code>","text":"<ul> <li>Defines options related to inventory parsing and caching.</li> <li>Inventory is a critical component of Ansible, as it defines the hosts and groups of hosts that Ansible will manage.</li> <li>The inventory can be specified in various formats, including <code>INI</code> files, <code>YAML</code> files, and dynamic inventory scripts.</li> <li>The inventory can also be cached to improve performance.</li> <li> <p>Here are some commonly used settings in the <code>[inventory]</code> section:</p> <ul> <li><code>enable_plugins</code> - Specifies the inventory plugins to use.</li> <li><code>cache</code> - If set to true, inventory caching will be enabled.</li> <li><code>cache_plugin</code> - Specifies the inventory cache plugin to use.</li> <li><code>cache_timeout</code> - Specifies the timeout for inventory caching in seconds.</li> <li><code>inventory_ignore_extensions</code> - Specifies file extensions to ignore when loading inventory files.</li> <li><code>inventory_loader</code> - Specifies the inventory loader to use.</li> <li><code>strict</code> - If set to true, Ansible will enforce strict inventory parsing.</li> <li><code>host_key_checking</code> - If set to true, Ansible will check SSH host keys for inventory hosts.</li> <li><code>enable_inventory_cache</code> - If set to true, inventory caching will be enabled.</li> <li><code>inventory_cache_timeout</code> - Specifies the timeout for inventory caching in seconds.</li> <li><code>inventory_cache_connection</code> - Specifies the connection string for the inventory cache plugin.</li> </ul> <pre><code>[inventory]\n    enable_plugins      =    host_list, ini, auto\n    cache               =    True\n    cache_plugin        =    memory\n    cache_timeout       =    3600\n</code></pre> </li> </ul>"},{"location":"001-verify-ansible/#logging","title":"<code>[logging]</code>","text":"<ul> <li>Ansible does not have a dedicated <code>[logging]</code> section in <code>ansible.cfg</code>. </li> <li>Instead, logging is typically configured under the <code>[defaults]</code> section using the <code>log_path</code> directive.</li> <li><code>log_path</code> controls where Ansible logs its output. </li> <li>If <code>log_path</code> is set, Ansible will write logs to the specified file, where as if it is not set, or left empty, logging will be disabled.</li> <li>Here is an example of how to configure logging in the <code>[defaults]</code> section:     <pre><code>[defaults]\n    log_path            =     /var/log/ansible.log\n    log_level           =     info\n    log_format          =     default\n    log_date_format     =     iso8601\n    log_ansi            =     True\n    log_color           =     auto\n    log_file            =     /var/log/ansible.log\n    log_rotate          =     True\n    log_max_size        =     10485760\n    log_compress        =     True\n    log_backup_count    =     5\n    log_http            =     False\n    log_json            =     True\n</code></pre></li> </ul>"},{"location":"001-verify-ansible/#paramiko_connection","title":"<code>[paramiko_connection]</code>","text":"<ul> <li>The <code>[paramiko_connection]</code> section configures settings specific to the Paramiko SSH library, an alternative to OpenSSH for SSH connections.</li> <li> <p>Here are some commonly used settings in the <code>[paramiko_connection]</code> section:</p> <ul> <li><code>pty</code> - If set to true, a pseudo-terminal will be allocated for the connection.</li> <li><code>look_for_keys</code> - If set to true, Paramiko will look for SSH keys</li> <li><code>banner_timeout</code> - Specifies the timeout for receiving the SSH banner.</li> <li><code>keepalive</code> - If set to true, keepalive messages will be sent to</li> </ul> <pre><code>[paramiko_connection]\n    pty                 =    False\n    look_for_keys       =    True\n</code></pre> </li> </ul>"},{"location":"001-verify-ansible/#privilege_escalation","title":"<code>[privilege_escalation]</code>","text":"<ul> <li>The <code>[privilege_escalation]</code> section defines settings related to privilege escalation (such as <code>sudo</code> or <code>become</code>).</li> <li> <p>The <code>become</code> directive is used to enable privilege escalation.</p> </li> <li> <p>Here are some commonly used settings in the <code>[privilege_escalation]</code> section:</p> <ul> <li><code>become</code> - If set to true, privilege escalation will be used.</li> <li><code>become_method</code> - Specifies the method to use for privilege escalation (e.g., sudo, su).</li> <li><code>become_user</code> - Specifies the user to become when using privilege escalation.</li> <li><code>become_ask_pass</code> - If set to true, Ansible will prompt for the privilege escalation password.</li> <li><code>become_flags</code> - Specifies any additional flags to pass to the privilege escalation command.</li> <li><code>become_exe</code> - Specifies the path to the privilege escalation executable.</li> <li><code>become_pass</code> - Specifies the password to use for privilege escalation.</li> </ul> <pre><code>[privilege_escalation]\n    become              =    True\n    become_method       =    sudo\n    become_user         =    root\n    become_ask_pass     =    False\n</code></pre> </li> </ul>"},{"location":"001-verify-ansible/#ssh_connection","title":"<code>[ssh_connection]</code>","text":"<ul> <li>Settings for SSH connections, (timeout, control settings etc).</li> <li>ControlMaster and ControlPersist options are used for SSH multiplexing, allowing multiple SSH sessions to share a single connection.</li> <li><code>ssh_args</code> can be used to pass additional options to the SSH command.</li> <li><code>pipelining</code> can be enabled to reduce the number of SSH connections.</li> <li> <p><code>scp_if_ssh</code> specifies whether to use <code>SCP</code> for file transfers when using SSH.</p> <pre><code>[ssh_connection]\n    ssh_args            =    -o ControlMaster=auto -o ControlPersist=60s\n    pipelining          =    True\n    scp_if_ssh          =    True\n</code></pre> </li> </ul>"},{"location":"001-verify-ansible/#winrm","title":"<code>[winrm]</code>","text":"<ul> <li>The <code>[winrm]</code> section configures settings for Windows Remote Management (WinRM) connections, used for managing Windows hosts.</li> <li> <p>Here are some commonly used settings in the <code>[winrm]</code> section:</p> <ul> <li><code>transport</code> - Specifies the transport method to use (e.g., basic, ntlm).</li> <li><code>cert_validation</code> - Controls certificate validation (e.g., ignore, validate).</li> <li><code>read_timeout_sec</code> - Specifies the read timeout for WinRM connections in seconds.</li> <li><code>operation_timeout_sec</code> - Specifies the operation timeout for WinRM connections in seconds.</li> <li><code>max_retries</code> - Specifies the maximum number of retries for WinRM connections.</li> <li><code>retry_delay</code> - Specifies the delay between retries for WinRM connections.</li> </ul> <pre><code>[winrm]\n    transport           =    basic\n    cert_validation     =    ignore\n</code></pre> </li> </ul>"},{"location":"001-verify-ansible/#05-auto-generate-ansiblecfg","title":"05. Auto Generate <code>ansible.cfg</code>","text":"<ul> <li>You can choose to execute <code>ansible-config init</code>, which will generate a sample Ansible configuration file. </li> <li> <p>As this is the main configuration file for our demo application, it is the content of <code>ansible.cfg</code> which we will use in this lab.</p> <pre><code># File location: $RUNTIME_FOLDER/labs-scripts/ansible.cfg.\n# This is the default location of the inventory file, script, or directory that \nAnsible will use to determine what hosts it has available to talk to.\n\n# Defines that the inventory info is in a file named \u201cinventory\u201d.\n[defaults]\n    inventory = inventory\n\n# Specifies remote hosts, so we do not need to config them in main SSH config.\n[ssh_connection]\n    transport = ssh\n    transfer_method = scp\n\n    # The location of the SSH config file.\n    # We will create this file in our next step.\n    ssh_args  = -F ssh.config                   \\\n                -o ControlMaster=auto           \\\n                -o ControlPersist=60s           \\\n                -o StrictHostKeyChecking=no     \\\n                -o UserKnownHostsFile=/root/.ssh/known_hosts\n</code></pre> </li> </ul>"},{"location":"001-verify-ansible/#06-create-the-sshconfig-file","title":"06. Create the <code>ssh.config</code> file","text":"<ul> <li>Ansible operates in Linux environments using <code>SSH</code> protocol, in order to run Ansible playbooks.</li> <li>By default, Ansible uses the default SSH keys, unless provided with an SSH configuration file.</li> <li>Ansible ssh.config file allows you to define custom SSH settings for connecting to remote hosts.</li> <li>In this demo we will use our own <code>ssh.config</code> configuration file.     <pre><code># File location: $RUNTIME_FOLDER/labs-scripts/ssh.config\n# Set up the desired hosts\n# keep in mind that we have set up the hosts in the docker-compose\n\nHost *\n\n# Disable host key checking\n# Avoid asking for the key-print authenticity\nStrictHostKeyChecking no        \nUserKnownHostsFile    /dev/null\n\n# Enable hashing known_host file\nHashKnownHosts        yes\n\n# IdentityFile allows to specify private keys we wish to use for authentication\n# Authentication = the process of authentication\n# We will use the auto-generated SSH keys from our Docker container\n\n# List the desired servers\n# The hosts are defined in the docker-compose which we created in the setup lab\n\nHost                  linux-server-1\n    HostName          linux-server-1\n    IdentityFile      /root/.ssh/linux-server-1\n    User              root\n    Port              22\n\nHost                  linux-server-2\n    HostName          linux-server-2\n    IdentityFile      /root/.ssh/linux-server-2\n    User              root\n    Port              22\n\nHost                  linux-server-3\n    HostName          linux-server-3\n    IdentityFile      /root/.ssh/linux-server-3\n    User              root\n    Port              22\n</code></pre></li> </ul>"},{"location":"001-verify-ansible/#07-create-the-inventory-file","title":"07. Create the <code>inventory</code> file","text":"<ul> <li>See Ansible documentation: How to build your inventory.</li> <li>An Ansible inventory file is a <code>configuration file</code> that lists and categorizes the hosts Ansible will manage. </li> <li>It provides a structured way to define <code>hosts</code> and <code>groups</code>, enabling efficient targeting and execution of tasks on specific hosts or groups of hosts.</li> <li>The simplest inventory is a single file with a list of <code>hosts</code> and <code>groups</code>.</li> <li>The inventory is written using the <code>INI</code> format.</li> <li><code>inventory</code> can be written in other formats as well, such as <code>YAML</code> and <code>Dynamic Inventory</code> which dynamically configure the inventory with scripts. </li> <li>The default location for this file is <code>/etc/ansible/hosts</code>.</li> <li>If <code>/etc/ansible/hosts</code> doesn\u2019t exists, ansible will look for user specific inventory file, to be placed at <code>$HOME/.ansible/hosts</code></li> <li>You can specify a different inventory file at the command line using the <code>-i &lt;path&gt;</code> inventory option when executing Ansible commands or by exporting the <code>ANSIBLE_INVENTORY</code> environment variable.</li> <li>Using <code>-i &lt;path&gt;</code> inventory option takes precedence over environment variable.</li> <li>The inventory configuration we will use for the labs:     <pre><code># File location: $RUNTIME_FOLDER/labs-scripts/inventory\n\n# List of servers which we want ansible to connect to\n# The names are defined in the docker-compose\n\n[servers]\n    linux-server-1 ansible_ssh_common_args='-o UserKnownHostsFile=/root/.ssh/known_hosts'\n    linux-server-2 ansible_ssh_common_args='-o UserKnownHostsFile=/root/.ssh/known_hosts'\n    linux-server-3 ansible_ssh_common_args='-o UserKnownHostsFile=/root/.ssh/known_hosts'\n\n[all:vars]\n\n# Extra \"global\" variables for the inventory\n</code></pre></li> </ul> <p>This inventory file is written following these rules:</p> <ul> <li>Information is described by one node per line, such as <code>linux-server-xx</code>.</li> <li>A node line consists of an <code>identifier of the node (ex. linux-server-X)</code> and a <code>host variable(s) (ex. ansible_host=xxxx)</code>, to be given to the node .</li> <li>You can also specify an IP address or FQDN for the <code>linux-server-xx</code> part.</li> <li>You can create a group of hosts with <code>[group_name]</code>. In our inventory the group name is <code>[servers]</code>.</li> <li> <p>You can use any group name except <code>[all]</code> and <code>[localhost]</code> (e.g., <code>[webservers]</code> or <code>[databases]</code> can be used as group names for servers).</p> <p><code>[all]</code></p> <ul> <li><code>all</code> is a special group that points to all nodes described in the inventory.</li> <li>The <code>[all:vars]</code> &amp; <code>group variables</code> are defined for the group <code>all</code>.<ul> <li>When we use a group, we can use the whole group as \u201chosts\u201d for ansible.</li> </ul> </li> <li>A magic variable, represented by <code>ansible_xxxx</code>,  contains special values that control Ansible\u2019s behavior and environment information that Ansible will automatically retrieve.  </li> <li>Details are explained in the variables section.</li> </ul> </li> </ul>"},{"location":"001-verify-ansible/#08-prepare-for-execution","title":"08. Prepare for execution","text":"<ul> <li>Place the files under the shared folder or simply execute the script /Labs/000-setup/02-init-ansible.sh</li> <li>Verify that the controller can execute ansible /Labs/000-setup/01-init-servers.sh</li> </ul>"},{"location":"001-verify-ansible/#09-test-ansible-configuration","title":"09. Test Ansible configuration","text":"<ul> <li> <p>Now we are ready to start play with <code>Ansible</code>!</p> </li> <li> <p>The first step is to test <code>Ansible</code> configuration     <pre><code># Verify that Ansible is installed correctly\ndocker exec ansible-controller ansible --version\n</code></pre></p> </li> <li> <p>Sample output</p> <pre><code>ansible [core 2.17.9]\nconfig file = /labs-scripts/ansible.cfg\nconfigured module search path = ['/root/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules']\nansible python module location = /usr/lib/python3/dist-packages/ansible\nansible collection location = /root/.ansible/collections:/usr/share/ansible/collections\nexecutable location = /usr/bin/ansible\npython version = 3.12.3 (main, Feb  4 2025, 14:48:35) [GCC 13.3.0] (/usr/bin/python3)\njinja version = 3.1.2\nlibyaml = True\n</code></pre> </li> <li> <p>We are looking for the following line:     <pre><code>config file = /labs-scripts/ansible.cfg\n</code></pre></p> </li> </ul>"},{"location":"001-verify-ansible/#10-basic-ansible-configuration","title":"10. Basic ansible configuration","text":"<ul> <li>Once all is ready, lets check if the controller can connect to the servers with the Ansible <code>ping</code> command.</li> <li> <p><code>ping</code> is an <code>Ad-Hoc</code> Ansible command that we will cover later on.</p> <pre><code># Ping the servers and check that they are \"alive\"\ndocker exec ansible-controller sh -c \"cd /labs-scripts &amp;&amp; ansible all -m ping\"\n\n### Output\n* Executing: ansible all -m ping\nlinux-server-2 | SUCCESS =&gt; {\n    \"ansible_facts\": {\n        \"discovered_interpreter_python\": \"/usr/bin/python3\"\n    },\n    \"changed\": false,\n    \"ping\": \"pong\"\n}\nlinux-server-1 | SUCCESS =&gt; {\n    \"ansible_facts\": {\n        \"discovered_interpreter_python\": \"/usr/bin/python3\"\n    },\n    \"changed\": false,\n    \"ping\": \"pong\"\n}\nlinux-server-3 | SUCCESS =&gt; {\n    \"ansible_facts\": {\n        \"discovered_interpreter_python\": \"/usr/bin/python3\"\n    },\n    \"changed\": false,\n    \"ping\": \"pong\"\n}\n</code></pre> </li> </ul>"},{"location":"002-no-inventory/","title":"002 No Inventory","text":""},{"location":"002-no-inventory/#lab-002-no-inventory","title":"Lab 002 - No Inventory","text":"<ul> <li>In this lab we will learn about Ansible inventory and how it affects automation tasks.</li> <li>We will start with an empty inventory and observe Ansible\u2019s behavior with no hosts defined. Later, we will create and test the inventory file.</li> <li>This lab is based upon the previous lab and its docker-compose setup.</li> </ul>"},{"location":"002-no-inventory/#pre-requirements","title":"Pre-Requirements","text":"<ul> <li>Complete the previous lab in order to have <code>Ansible</code> configured.</li> </ul>"},{"location":"002-no-inventory/#01-clear-the-inventory","title":"01. \u201cClear\u201d the inventory","text":"<ul> <li>Let\u2019s clear the inventory from previous labs and walk through what is <code>inventory</code>.</li> </ul>"},{"location":"002-no-inventory/#02-create-the-inventory-file","title":"02. Create the <code>inventory</code> file","text":""},{"location":"002-no-inventory/#ansible-inventory","title":"Ansible Inventory","text":"<ul> <li>An <code>Ansible</code> <code>inventory</code> can either be a single file or a collection of files </li> <li>The <code>inventory</code> defines the <code>[hosts]</code> and <code>[groups]</code> of hosts upon which <code>Ansible</code> will operate. </li> <li>It\u2019s simply a list of servers that <code>Ansible</code> can connect with and manage.</li> </ul>"},{"location":"002-no-inventory/#key-features-of-ansible-inventory","title":"Key features of Ansible inventory","text":"<ul> <li>Can be in various formats, such as <code>INI</code>, <code>JSON</code>, <code>YAML</code> and more.</li> <li><code>YAML</code>  being the most common format.</li> <li><code>inventory</code> defines the target hosts for <code>playbook</code> execution.</li> <li><code>inventory</code> organizes hosts into logical groups for easier management.</li> <li><code>inventory</code> can store host-specific variables and group variables.</li> <li><code>inventory</code> supports nested groups (groups of groups).</li> </ul>"},{"location":"002-no-inventory/#03-inventory-samples","title":"03. <code>inventory</code> samples","text":"<ul> <li> <p><code>INI</code> format     <pre><code>[webservers]\nweb1.example.com\nweb2.example.com\n\n[database]\ndb1.example.com\n</code></pre></p> </li> <li> <p><code>YAML</code> format     <pre><code>all:\n    hosts:\n        web1.example.com:\n        web2.example.com:\n    children:\n        database:\n        hosts:\n            db1.example.com:\n</code></pre></p> </li> <li> <p><code>JSON</code> format     <pre><code>{\n\"all\": {\n    \"hosts\": {\n    \"web1.example.com\": {\n        \"ansible_port\": 2222,\n        \"http_port\": 80\n    },\n    \"web2.example.com\": {\n        \"ansible_port\": 2223,\n        \"http_port\": 8080\n    }\n    },\n    \"children\": {\n    \"database\": {\n        \"hosts\": [\n        \"db1.example.com\"\n        ]\n      }\n    }\n  }\n}\n</code></pre></p> </li> </ul>"},{"location":"002-no-inventory/#inventory-types-in-ansible","title":"Inventory types in Ansible","text":"<ol> <li> <p>Static Inventory</p> <ul> <li>This is generally a simple text file (usually in INI or YAML format) that lists the hosts and their corresponding groups.</li> </ul> </li> <li> <p>Dynamic Inventory</p> <ul> <li>This is generated by a script or a program that retrieves host information from an external source (such as cloud providers like <code>AWS</code>, <code>Azure</code>, etc.), <code>LDAP</code> or from a <code>database</code>. </li> <li>This allows for real-time updates and adaptability as environments change.</li> </ul> <p>See an example of generating a <code>dynamic inventory</code> using <code>Python</code> code for fetching data from a database:</p> <pre><code>```python\n#!/usr/bin/env python\nimport sqlite3\nimport json\n\ndef get_inventory():\n    conn = sqlite3.connect('servers.db')\n    cursor = conn.cursor()\n\n    cursor.execute('SELECT hostname, group_name, ansible_user FROM servers')\n    rows = cursor.fetchall()\n\n    inventory = {'all': {'hosts': [], 'vars': {}}}\n\n    for row in rows:\n        hostname, group_name, ansible_user = row\n\n        if group_name not in inventory:\n            inventory[group_name] = {'hosts': [], 'vars': {}}\n\n        inventory['all']['hosts'].append(hostname)\n        inventory[group_name]['hosts'].append(hostname)\n        inventory[group_name]['vars']['ansible_user'] = ansible_user\n\n    conn.close()\n    return inventory\n\nif __name__ == \"__main__\":\n    print(json.dumps(get_inventory()))\n```\n</code></pre> </li> </ol>"},{"location":"002-no-inventory/#04-lab-exercise","title":"04. Lab exercise","text":"<ul> <li> <p>Let\u2019s create the inventory configuration that we will use for the labs:</p> <pre><code>### File location: $RUNTIME_FOLDER/labs-scripts/inventory\n###\n### List of servers which we want Ansible to connect to\n### The names are defined in the docker-compose\n###\n\n[servers]\n# No server will be defined at this step\n</code></pre> </li> </ul>"},{"location":"002-no-inventory/#05-no-inventory-invocation","title":"05. No inventory invocation","text":"<ul> <li> <p>Once all is ready, let\u2019s check if the controller can connect to the servers using <code>ping</code></p> <pre><code># Ping the servers and check that they are \"alive\"\ndocker exec ansible-controller sh -c \"cd /labs-scripts &amp;&amp; ansible all -m ping\"\n\n## Output\n## -------------------------------------------------------------------------------\n[WARNING]: provided hosts list is empty, only localhost is available. Note that\nthe implicit localhost does not match 'all'\n</code></pre> </li> </ul>"},{"location":"002-no-inventory/#06-inventory-invocation","title":"06. <code>inventory</code> invocation","text":"<ul> <li>Fill in the inventory based upon the previous labs\u2019 configuration and test it.</li> <li>Verify that the inventory is defined correctly with:      <pre><code>ansible-inventory -i &lt;inventory_file&gt; --graph\n</code></pre></li> <li>Test the inventory file with     <pre><code>ansible -i &lt;inventory_file&gt; -m ping\n</code></pre></li> <li> <p> Suggested Solution <p><pre><code>###\n### List of servers which we want ansible to connect to\n### The names are defined in the docker-compose\n###\n\n[servers]\n  linux-server-1 ansible_ssh_common_args='-o UserKnownHostsFile=/root/.ssh/known_hosts'\n  linux-server-2 ansible_ssh_common_args='-o UserKnownHostsFile=/root/.ssh/known_hosts'\n  linux-server-3 ansible_ssh_common_args='-o UserKnownHostsFile=/root/.ssh/known_hosts'\n</code></pre> </p>"},{"location":"003-modules/","title":"003 Modules","text":""},{"location":"003-modules/#lab-003-commands-modules","title":"Lab 003 - Commands &amp; Modules","text":"<ul> <li>In this section, we will cover the Modules.</li> <li>Modules are important elements and act as the \u201cheart\u201d of <code>Ansible</code>.</li> </ul>"},{"location":"003-modules/#pre-requirements","title":"Pre-Requirements","text":"<ul> <li>Complete the previous lab in order to have a working <code>Ansible</code> controller and inventory configuration.</li> </ul>"},{"location":"003-modules/#01-what-is-a-module","title":"01. What is a module?","text":"<ul> <li>A module is a unit of code in <code>Ansible</code> that performs common operations in infrastructure management (such as configuring systems, installing software and managing resources). </li> <li><code>Ansible</code> has a huge number of modules. </li> <li>You can browse and search <code>Ansible</code> builtin modules in the Builtin Ansible modules.</li> <li>Module are used for task automation.</li> </ul>"},{"location":"003-modules/#02-a-sample-module","title":"02. A sample module","text":"<ul> <li>In this lab we will explore the builtin <code>ping</code> module.</li> <li>You can read about this module in the Ansible documentation.</li> <li>You can find the source code for this module in Builtin ping module repo.</li> </ul>"},{"location":"003-modules/#03-the-ping-module","title":"03. The ping module","text":"<p>From the docs:</p> <ul> <li>ansible.builtin.ping module \u2013 Try to connect to host, verify a usable python and return pong on success</li> <li>This module is part of ansible-core and included in all Ansible installations.</li> <li>In most cases, you can use the short module name <code>ping</code></li> </ul> <ul> <li>Now, as we break down the code, feel free to browse and look at the full code.</li> </ul>"},{"location":"003-modules/#04-the-ping-source-code","title":"04. The ping source code","text":"<ul> <li>At the time of writing this tutorial, the \u201cimplementation\u201d of the <code>ping</code> module is as follows: <pre><code>RETURN = '''\nping:\n    description:  Value provided with the O(data) parameter.\n    returned:     success\n    type:         str\n    sample:       pong\n'''\n\nfrom ansible.module_utils.basic import AnsibleModule\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict(\n            data=dict(type='str', default='pong'),\n        ),\n        supports_check_mode=True\n    )\n\n    if module.params['data'] == 'crash':\n        raise Exception(\"boom\")\n\n    result = dict(\n        ping=module.params['data'],\n    )\n\n    module.exit_json(**result)\n\nif __name__ == '__main__':\n    main()\n</code></pre></li> </ul>"},{"location":"003-modules/#05-list-of-modules","title":"05. List of modules","text":"<ul> <li>Modules are managed in the form of <code>collections</code>, as each <code>collection</code> contains multiple related modules. </li> <li>See here for a List of Collections.</li> </ul> <p>Note</p> <p>Up to version 2.9, <code>Ansible</code> included all modules by default,  but as the number of modules increased tremendously, it has been changed to the current format (ver. 2.10 and later).</p>"},{"location":"003-modules/#06-using-modules","title":"06. Using modules","text":"<ul> <li>By default <code>Ansible</code> is installed with <code>ansible.builtin</code> as the only collection. </li> <li>Click here for a list of modules that are available in the <code>ansible.builtin</code>.</li> </ul>"},{"location":"003-modules/#07-find-modules-for-your-os","title":"07. Find modules for your OS","text":"<ul> <li>To see which modules are available for your OS, use the following command:   <pre><code>ansible-doc -l\n\n### Output (only first few lines)\nadd_host        Add a host (and alternatively a group) to the ansible-playbook in-memory inventor...\napt             Manages apt-packages\napt_key         Add or remove an apt key\napt_repository  Add and remove APT repositories\nassemble        Assemble configuration files from fragments\nassert          Asserts given expressions are true\nasync_status    Obtain status of asynchronous task\nblockinfile     Insert/update/remove a text block surrounded by marker lines\n</code></pre></li> </ul>"},{"location":"003-modules/#08-documentation","title":"08. Documentation","text":"<ul> <li>To view documentation for a specific module, use the following command:   <pre><code># Display the ping documentation\n$ ansible-doc ping\n\n### Output (only first few lines)\n&gt; ANSIBLE.BUILTIN.PING    (/opt/homebrew/Cellar/ansible/9.4.0_1/libexec/lib/python3.12/site-packages/ansible/modules/ping&gt;\n\n      A trivial test module, this module always returns `pong' on successful contact. It does\n      not make sense in playbooks, but it is useful from `/usr/bin/ansible' to verify the\n      ability to login and that a usable Python is configured. This is NOT ICMP ping, this is\n      just a trivial test module that requires Python on the remote-node. For Windows targets,\n      use the [ansible.windows.win_ping] module instead. For Network targets, use the\n      [ansible.netcommon.net_ping] module instead.\n\nADDED IN: historical\n\nOPTIONS (= is mandatory):\n\n- data\n      Data to return for the `ping' return value.\n</code></pre></li> </ul>"},{"location":"003-modules/#09-common-ad-hoc-commands","title":"09. Common ad-hoc commands","text":"<ul> <li>Invoking a module is referred to as an <code>ad-hoc command</code>.</li> <li> <p>The syntax of an <code>ad-hoc command</code> is as follows:   <pre><code>$ ansible &lt;servers&gt; -m &lt;module_name&gt; -a '&lt;parameters&gt;'\n</code></pre></p> CLI option Description <code>&lt;servers&gt;</code> Any server (single, group or all) as defined in the inventory file <code>-m &lt;module_name&gt;</code> Specifies the module name <code>-a &lt;parameters&gt;</code> Specifies the parameters to be passed to the module. Optional in most cases </li> </ul>"},{"location":"003-modules/#10-ping-usage","title":"10. <code>Ping</code> usage","text":"<ul> <li>We are already familiarized with the ping module. </li> </ul> <p>Tips</p> <ul> <li>The <code>ping</code> module is a module that determines whether Ansible can \u201ccommunicate as Ansible\u201d with the node it is working on (which is different from ICMP used in the network). </li> <li>The <code>ping</code> module parameters are optional.</li> </ul> <ul> <li>Usage:</li> </ul> <pre><code># Ping all server in the inventory\nansible all -m ping\n\n# In our demo lab we will execute it, as follows:\ndocker exec ansible-controller sh -c \"cd /labs-scripts &amp;&amp; ansible all -m ping\"\n\n\n### Output\nlinux-server-1 | SUCCESS =&gt; {\n    \"ansible_facts\": {\n        \"discovered_interpreter_python\": \"/usr/bin/python3\"\n    },\n    \"changed\": false,\n    \"ping\": \"pong\"\n}\nlinux-server-3 | SUCCESS =&gt; {\n    \"ansible_facts\": {\n        \"discovered_interpreter_python\": \"/usr/bin/python3\"\n    },\n    \"changed\": false,\n    \"ping\": \"pong\"\n}\nlinux-server-2 | SUCCESS =&gt; {\n    \"ansible_facts\": {\n        \"discovered_interpreter_python\": \"/usr/bin/python3\"\n    },\n    \"changed\": false,\n    \"ping\": \"pong\"\n}\n</code></pre>"},{"location":"003-modules/#11-the-shell-module","title":"11. The <code>shell</code> module","text":"<ul> <li>This is a module that executes shell commands on targets\u2019 nodes.</li> <li>See <code>Ansible</code> documentation about the <code>shell</code> module.</li> </ul> <p>TIP</p> <p>Be cautious when using the <code>shell</code> module, as it can introduce security risks if not used properly. Always validate and sanitize any user input that may be passed to shell commands.</p> <pre><code># Let's get the hostname of the server\nansible all -m shell -a 'hostname'\n\n# In our demo lab we will execute it like this:\ndocker exec ansible-controller sh -c \"cd /labs-scripts &amp;&amp; ansible all -m shell -a 'hostname'\"\n\n# Output\n# ansible all -m shell -a 'hostname' \nlinux-server-3 | CHANGED | rc=0 &gt;&gt;\nlinux-server-3\nlinux-server-2 | CHANGED | rc=0 &gt;&gt;\nlinux-server-2\nlinux-server-1 | CHANGED | rc=0 &gt;&gt;\nlinux-server-1\n</code></pre> <p></p>"},{"location":"003-modules/#12-hands-on","title":"12. Hands-on","text":"<ol> <li> <p>Figure out a way to run the following (shell) command with <code>Ansible</code>, on any of the servers:</p> <pre><code># Get kernel information\nuname -a\n\n# Get a date\ndate\n</code></pre> </li> <li> <p>Use the Ansible <code>command</code> module to print out the previous shell commands.</p> </li> <li> <p>Try to run the following command:  <pre><code>git config -l\n</code></pre>   What is the result of this command?</p> </li> </ol>"},{"location":"003-modules/#13-solution","title":"13. Solution","text":"uname -a <pre><code># Using the shell module\ndocker exec ansible-controller sh -c \"cd /labs-scripts &amp;&amp; ansible linux-server-1 -m shell -a 'uname -a'\"\n\n#Using the ansible `command` module\ndocker exec ansible-controller sh -c \"cd /labs-scripts &amp;&amp; ansible linux-server-1 -m command -a 'uname -a'\"\n</code></pre> date <pre><code># Using the shell module\ndocker exec ansible-controller sh -c \"cd /labs-scripts &amp;&amp; ansible linux-server-1 -m shell -a 'date'\"\n\n#Using the ansible `command` module\ndocker exec ansible-controller sh -c \"cd /labs-scripts &amp;&amp; ansible linux-server-1 -m command -a 'date'\"\n</code></pre> previous shell commands <pre><code>docker exec ansible-controller sh -c \"cd /labs-scripts &amp;&amp; ansible all -m command -a 'uname -a'\"\ndocker exec ansible-controller sh -c \"cd /labs-scripts &amp;&amp; ansible all -m command -a 'date'\"\n</code></pre> git config <pre><code># The command\ngit config -l\n\n### Output\nuser.name=Your Name\nuser.email=your.email@example.com\ncore.repositoryformatversion=0\ncore.filemode=true\ncore.bare=false\n</code></pre>"},{"location":"004-playbooks/","title":"004 Playbooks","text":""},{"location":"004-playbooks/#lab-004-playbooks","title":"Lab 004 - Playbooks","text":"<ul> <li>In this section, we will cover the Ansible Playbooks.</li> <li>Playbooks are essentially \"Ansible scripts\" serving as one of <code>Ansible's</code> building blocks.</li> </ul>"},{"location":"004-playbooks/#pre-requirements","title":"Pre-Requirements","text":"<ul> <li>Complete the lab 002 in order to have <code>Ansible</code> set up.</li> </ul>"},{"location":"004-playbooks/#01-what-are-playbooks","title":"01. What are playbooks?","text":"<ul> <li>In the previous labs, we have executed an <code>Ansible ad-hoc command</code> which invoked modules.</li> <li>In real life we need more than just <code>modules</code>\u2026</li> <li>This is where <code>Ansible playbook</code> jumps in for the rescue.</li> <li><code>Ansible playbooks</code> are essentially blueprints of automation tasks. </li> <li>They are written in <code>YAML</code> format, and are used to automate tasks on remote hosts. </li> <li>In summary, <code>Ansible playbooks</code> offer a repeatable, reusable and simple configuration management &amp; multi-machine deployment system, well suited to deploying complex applications. </li> <li><code>Ansible playbooks</code> are a powerful tool for automating infrastructure management.</li> </ul>"},{"location":"004-playbooks/#02-key-points","title":"02. Key points","text":"<ul> <li> <p>Structure - A playbook is composed of one or more <code>plays</code>, in an ordered list (Sequence).    Each play executes part of the overall goal of the playbook, running one or more tasks, whereas each task calls an <code>Ansible module</code>.</p> </li> <li> <p>Execution - A playbook runs in sequential order, from top to bottom. Within each play, tasks also run in a sequential order, from top to bottom. Playbooks containing multiple <code>plays</code> can orchestrate multi-machine deployments.</p> </li> <li> <p>Functionality - Playbooks can declare configurations and orchestrate steps of any manual ordered process, on multiple sets of machines, in a pre-defined order, while launching tasks, either synchronously or asynchronously.</p> </li> <li> <p>Use Cases - Playbooks are regularly used to automate IT infrastructure, networks, security systems and code repositories (like GitHub). IT staff can also use playbooks to program applications, services, server nodes and other devices.</p> </li> <li> <p>Reusability - The conditions, variables and tasks within playbooks can be saved, shared or reused indefinitely. This makes it easier for IT teams to codify operational knowledge and ensure that the same actions are performed consistently across different environments.</p> </li> </ul>"},{"location":"004-playbooks/#03-playbook-basics","title":"03. Playbook basics","text":""},{"location":"004-playbooks/#yaml","title":"YAML","text":"<ul> <li>The <code>playbook</code> is usually written in YAML format.</li> <li>Nevertheless, <code>playbooks</code> can be written in JSON format as well.</li> <li>In this lab we will be using only YAML format for <code>playbooks</code>.</li> <li>YAML is a text file that uses \u201cPython-style\u201d indentation to indicate nesting, which does not require quotes around most string values.</li> <li>Files should start with <code>---</code>.</li> <li>As indentations have meanings, they are extremely important!!!</li> <li>Indentation should be written using <code>space</code>, as using <code>tab</code> will result in an error.</li> <li>The level of indentation (using spaces, not tabs) is used to denote structure.</li> <li>Building the playbook using Key-Value Pairs, making them as dictionary in YAML that is represented in a simple <code>key</code>: <code>value</code> form.</li> <li>The <code>:</code> (colon) must be followed by a space.</li> <li>All members of a <code>list</code> are lines beginning at the same indentation level starting with a <code>-</code> (a dash and a space).</li> <li>As values can span multiple lines, using <code>|</code> or <code>&gt;</code>, <code>playbooks</code> support Multi-Line Strings. </li> <li>Using a <code>Literal Block Scalar</code>  [<code>|</code>] will include the newlines and any trailing spaces. </li> <li>Using a <code>Folded Block Scalar</code>   [<code>&gt;</code>] will fold new lines into spaces.</li> <li>Boolean Values (true/false) can be specified in several forms. For example, use a lowercase <code>true</code> or <code>false</code> boolean value in dictionaries in order to be compatible with default yamllint options.</li> <li>YAML is case sensitive, so be careful with your capitalization.</li> </ul>"},{"location":"004-playbooks/#04-our-first-playbook","title":"04. Our first playbook","text":"<ul> <li>Here is our first playbook example that will list files in a given directory.</li> </ul> <pre><code>---\n# Run on all the hosts\n- hosts: all\n\n  # Here we define our tasks\n  tasks:  \n    # This is the first task \n    - name: List files in a directory  \n      # As learned before this is the command module\n      # This command will list files in the home directory\n      command: ls ~  \n\n      # register is used whenever we wish to save the output \n      # In this case it will be saved to a variable named 'files'\n      register: files  \n\n    # This is the second task\n    # In this case the tasks will run in the declared sequence \n    - name: Print the list of files  \n      # Using the builtin debug module \n      # The debug will print out our files list\n      # ** We need to use `stdout_lines` for that\n      debug:  \n        msg: \"{{ files.stdout_lines }}\"  \n</code></pre>"},{"location":"004-playbooks/#writing-a-playbook","title":"Writing a playbook","text":"<ul> <li>Let\u2019s open the editor and write the first playbook in <code>YAML</code> format.</li> </ul>"},{"location":"004-playbooks/#playbook-content","title":"Playbook content:","text":"<ul> <li><code>YAML</code> should start with the <code>---</code></li> <li>Define the hosts we wish to run on. In this sample we will use our <code>localhost</code>.  </li> <li>Define the playbook tasks.</li> </ul>"},{"location":"004-playbooks/#its-as-simple-as-that","title":"It\u2019s as simple as that!","text":""},{"location":"004-playbooks/#hands-on","title":"Hands-on","text":"<ul> <li> <p>Use the following code skeleton for our first playbook:   <pre><code># List of hosts\n- hosts: \n\n  # List of tasks\n  tasks:\n    - name: Execute 'uname -a'\n\n    - name: Print 'uname -a' output\n\n    - name: Execute 'id'\n\n    - name: Print 'id' output\n</code></pre></p> </li> <li> <p>Now let\u2019s fill it in with content.</p> </li> <li>First lets define localhost as the host for this playbook:   <pre><code>---\n- hosts: localhost\n</code></pre></li> <li>Next steps is to define the tasks:</li> </ul> <p>TIP</p> <p>Like in every other programming / scripting language, there is no one \u201cright\u201d or \u201cwrong\u201d solution. The bellow solution will work like any other solution that will work for you, so feel free to write it any way which works best for you.</p> <pre><code># List of hosts\n- hosts: localhost\n\n  ###\n  ### In this sample we display several solutions\n  ### \n  ### We combine few commands like: `shell`, `debug`, `command` and more\n  ###\n\n  # List of tasks\n  tasks:\n    # Using shell it will work, but no out put will be displayed out\n    # We will need to use register to display output\n    - name: Execute 'uname -a'\n      shell: uname -a\n      register: task_output\n\n    # Using register we can now display the output contents\n    # We must use `.stdout` to display the output itself\n    - name: Print 'uname -a' output\n      debug: \n        msg: \"{{ task_output.stdout}}\"    \n\n### Output:\n\n* Executing Ansible ad-hoc commands\n\n$ ansible localhost -m shell -a 'uname -a'\nlocalhost | CHANGED | rc=0 &gt;&gt;\nLinux 1fa29998d58c 5.15.0-105-generic 115-Ubuntu SMP Mon Apr 15 09:52:04 \nUTC 2024 aarch64 aarch64 aarch64 GNU/Linux\n-----------------------------------\n\n* Executing ansible playbook\n\n$ cat 004-playbook.yaml\n  # List of hosts\n  - hosts: localhost\n\n    ###\n    ### In this sample we display several solutions\n    ###\n    ### We combine few commands like: `shell`, `debug`, `command` and more\n    ###\n\n    # List of tasks\n    tasks:\n      # Using shell it will work, but no out put will be displayed out\n      # We will need to use register to display output\n      - name: Execute 'uname -a'\n        shell: uname -a\n        register: task_output\n\n      # Using register we can now display the output contents\n      # We must use `.stdout` to display the output itself\n      - name: Print 'uname -a' output\n        debug:\n          msg: \"{{ task_output.stdout}}\"   \n</code></pre> <p> </p> <ul> <li>Complete the playbook, this time use <code>command</code> instead of shell:</li> </ul> <pre><code>$ ansible-playbook 004-install-nginx.yaml\n\nPLAY [localhost] ***************************************************************\n\nTASK [Gathering Facts] *********************************************************\nok: [localhost]\n\nTASK [Execute 'uname -a'] ******************************************************\nchanged: [localhost]\n\nTASK [Display the output] ******************************************************\nok: [localhost] =&gt; {\n    \"msg\": \"Linux 1fa29998d58c 5.15.0-105-generic #115-Ubuntu SMP Mon Apr 15\n    09:52:04 UTC 2024 aarch64 aarch64 aarch64 GNU/Linux\"\n}\n\nPLAY RECAP *********************************************************************\nlocalhost                  : ok=3    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0\n</code></pre>"},{"location":"004-playbooks/#05-playbook-syntax","title":"05. Playbook syntax","text":"<ul> <li>In this section, we will learn further about playbook\u2019s syntax.</li> </ul>"},{"location":"004-playbooks/#play","title":"<code>Play</code>","text":"<ul> <li>See official documentation.</li> <li>The top part of the playbook is called <code>Play</code> and it defines the global behavior of for the entire playbook.</li> <li>Here are some definitions which are set in the <code>Play</code> section:</li> </ul> <pre><code>---\n- name: The name of the play\n  # A list of groups, hosts or host pattern that translates into a list \n  # of hosts that are the play\u2019s target.\n  hosts: localhost\n\n  # Boolean that controls if privilege escalation is used or not on \n  # Task execution.\n  # Implemented by the become plugin\n  become: yes\n\n  # User that you \u2018become\u2019 after using privilege escalation. \n  # The remote/login user must have permissions to become this user.\n  become_user: \n\n  # A dictionary that gets converted into environment vars to be provided \n  # for the task upon execution. \n  # This can ONLY be used with modules. \n  # This is not supported for any other type of plugins nor Ansible itself \n  # nor its configuration, it just sets the variables for the code responsible\n  # for executing the task. \n  # This is not a recommended way to pass in confidential data.\n  environment: \n\n  # Dictionary/map of variables\n  vars: \n</code></pre>"},{"location":"004-playbooks/#06-quiz","title":"06. Quiz","text":"<ul> <li> <p>Review the example below and try to answer the following questions:</p> <ul> <li>On which hosts the playbook should be executed?</li> <li>How do we define the play?</li> <li>Which directives are defined in the below playbook?</li> <li>How do we define variables?</li> <li>How do we use variables?</li> <li>How do we set up a root user?</li> </ul> <pre><code>#\n# Install nginx\n#\nname: Install and start nginx\n\n# We should have this group in our inventory\nhosts: webservers\n\n# Variables\n# The `lookup` function is used to fetch the value of the environment variables \nvars:\n  env:\n    PORT: \"{{ lookup('env','PORT') }}\"\n    PASSWORD: \"{{ lookup('env','PASSWORD') }}\"\n\n# Define the tasks    \ntasks:\n  - name: Install nginx\n    apt:\n      name: nginx\n      state: present\n    become: yes\n\n  - name: Start nginx service\n    service:\n      name: nginx\n      state: started\n    become: yes\n\n  - name: Create a new secret with environment variable\n    shell: echo \"secret:{{ PASSWORD }}\" &gt; /etc/secret\n    become: yes\n\n  - name: Open the port in firewall\n    ufw:\n      rule: allow\n      port: \"{{ PORT }}\"\n      proto: tcp\n    become: yes\n</code></pre> </li> </ul>"},{"location":"004-playbooks/#07-playbook-demo","title":"07. Playbook demo","text":"<ul> <li>Execute the playbook by adding the required parameters.</li> <li>This can be done by setting up the parameters prior to executing the playbook, or by adding the parameters to the playbook itself.</li> </ul>"},{"location":"004-playbooks/#setting-the-env-variable-in-the-ansible-controller","title":"Setting the env variable in the Ansible controller","text":"<pre><code># Example: \n\n# 01. Setting the env variable in the Ansible controller\nexport PORT=8080\n\n# Use the -e/--extra-vars to inject environment variables into the playbook\nansible-playbook playbook.yaml -e \"my_var=$MY_VAR\"\n\n# Using the lookup Plug to fetch the value of the environment variables\nPORT: \"{{ lookup('env','PORT') }}\"\n</code></pre>"},{"location":"004-playbooks/#passing-the-variable-to-the-playbook","title":"Passing the variable to the playbook","text":"<pre><code># Example:\n\n# 02. Passing the variable to the playbook\nPORT=\"8080\" ansible-playbook playbook.yaml\n</code></pre>"},{"location":"004-playbooks/#using-the-environment","title":"Using the environment","text":"<pre><code># Example:\n\n# 0.3 Using the environment keyword in a **task** to set variables for that task\n- name: Open the port in firewall\n  environment:\n    PORT: \"8080\"\n  ufw:\n    rule: allow\n    port: \"{{ PORT }}\"\n    proto: tcp\n</code></pre>"},{"location":"004-playbooks/#passing-the-environment","title":"Passing the environment","text":"<pre><code># Example:\n\n# 0.4 Passing the environment to all the tasks in Playbook\n- hosts: all\n  environment:\n    PORT: \"8080\"\n  tasks:\n    - name: Open the port in firewall\n    ...\n</code></pre>"},{"location":"004-playbooks/#set-environment","title":"Set environment","text":"<pre><code># Example:\n\n# 05. Permanently set environment variables on remote hosts to persist variables \n#     (e.g., in .bashrc or /etc/environment)\n- name: Set permanent environment variable\n  lineinfile:\n    path: /etc/environment\n    line: 'PORT=\"8080\"'\n    state: present\n  become: yes\n</code></pre>"},{"location":"004-playbooks/#using-var_files-to-include-variables","title":"Using <code>var_files</code> to include variables","text":"<pre><code># Example\n\n# 06. We can use a variable file to pass variables in a playbook\n# Check the vars.yaml file in the same directory\n- hosts: all\n  vars_files:\n    - vars.yaml  # Include variables from vars.yaml\n  tasks:\n    - name: Print a variable\n      debug:\n        msg: \"{{ http_port }}\"\n</code></pre>"},{"location":"004-playbooks/#08-tasks","title":"08. Tasks","text":"<ul> <li> <p>See documentation on running playbooks in check mode.     <pre><code># To run a playbook in check mode, \n# you can pass the -C or --check flag to \n# the ansible-playbook command:\n\nansible-playbook --check playbook.yaml\n</code></pre></p> </li> <li> <p>Let\u2019s write some playbook tasks with parameters.</p> </li> <li>Take a look on <code>004-list-files.yaml</code> and follow the instructions in the comments.</li> <li>Answer the questions in the comments about the <code>with_items</code> output of the playbook.</li> </ul>"},{"location":"004-playbooks/#09-additional-tasks","title":"09. Additional tasks","text":"<ul> <li>Run the playbook and watch the output.</li> <li>Run the playbook in <code>check mode</code> and watch the output.</li> <li>Run the playbook with <code>--diff</code> flag and watch the output.</li> <li>Run the playbook with <code>--verbose</code> flag and watch the output.</li> <li>Run the playbook with <code>--verbose</code> and <code>--diff</code> flags and watch the output.</li> <li>Run the playbook with <code>--verbose</code>, <code>--diff</code> and <code>--check</code> flags and watch the output.</li> </ul> <p>TIP</p> <p>It\u2019s considered best practice to use the FQDN name of all modules used in your playbook. It is done to prevent naming collision between builtin modules and community modules or self made ones.</p>"},{"location":"005-facts/","title":"005 Facts","text":""},{"location":"005-facts/#lab-005-facts","title":"Lab 005 - Facts","text":"<ul> <li>In this section, we will cover Ansible Facts.</li> <li>Ansible facts are essentially \u201cAnsible Scripts\u201d and constitute one of the building blocks of Ansible.</li> <li>Ansible facts are data corresponding to your remote systems, which includes operating systems, IP addresses, attached filesystems, and more.</li> <li>Ansible facts are gathered, and relate to target nodes (host nodes to be configured). They are returned back to the controller node.</li> </ul>"},{"location":"005-facts/#01-how-to-view-facts","title":"01. How to View Facts?","text":"<ul> <li>Ansible gathers facts about remote systems using the <code>setup</code> module.</li> <li> <p>You can view facts of a remote machine by running the following command: <pre><code>ansible all -m setup\n</code></pre></p> </li> <li> <p>Example Output (Truncated for brevity):   <pre><code>{\n  \"ansible_facts\": {\n      \"ansible_distribution\": \"Ubuntu\",\n      \"ansible_distribution_version\": \"22.04\",\n      \"ansible_architecture\": \"x86_64\",\n      \"ansible_memory_mb\": {\n          \"real\": {\n              \"total\": 7989,\n              \"used\": 2034\n          }\n      },\n      \"ansible_default_ipv4\": {\n          \"address\": \"192.168.1.10\",\n          \"netmask\": \"255.255.255.0\",\n          \"gateway\": \"192.168.1.1\"\n      }\n  }\n}\n</code></pre></p> </li> </ul>"},{"location":"005-facts/#02-how-to-use-facts-in-playbooks","title":"02. How to use facts in playbooks?","text":"<ul> <li>Facts allow you to base your playbook logic on the properties of the target hosts.</li> <li>All facts are prefixed with <code>ansible_x</code>.</li> <li>For example, to access the operating system distribution of a host, you would use <code>ansible_distribution</code>.</li> <li>Here are some examples of how to use facts in playbooks:</li> </ul>"},{"location":"005-facts/#example-installing-packages-based-on-os","title":"Example: Installing Packages Based on OS","text":"<pre><code>---\n- hosts: all\n  tasks:\n    - name: Install Nginx on Debian using APT\n      ansible.builtin.apt:\n        name: nginx\n        state: present\n      when: ansible_distribution == \"Ubuntu\"\n\n    - name: Install Nginx on RedHat using DNF\n      ansible.builtin.dnf:\n        name: nginx\n        state: present\n      when: ansible_distribution == \"CentOS\"\n</code></pre>"},{"location":"005-facts/#example-conditional-execution-based-on-memory","title":"Example: Conditional execution based on memory","text":"<pre><code>- name: Restart Service if Memory is Low\n  ansible.builtin.service:\n    name: my_service\n    state: restarted\n  when: ansible_memory_mb.real.total &lt; 4000\n</code></pre>"},{"location":"005-facts/#03-commonly-used-facts","title":"03. Commonly used facts","text":""},{"location":"005-facts/#system-information","title":"System Information","text":"Fact Description <code>ansible_distribution</code> OS name (Ubuntu, CentOS, Windows) <code>ansible_distribution_version</code> OS version (22.04, 9.1, 10) <code>ansible_architecture</code> System architecture (x86_64, arm) <code>ansible_hostname</code> Hostname of the machine <code>ansible_os_family</code> OS family (Debian, RedHat, Windows) <code>ansible_facts</code> All gathered facts"},{"location":"005-facts/#networking","title":"Networking","text":"Fact Description <code>ansible_default_ipv4.address</code> Default IP address <code>ansible_default_ipv4.gateway</code> Default gateway <code>ansible_fqdn</code> Fully Qualified Domain Name <code>ansible_dns.nameservers</code> DNS servers"},{"location":"005-facts/#hardware","title":"Hardware","text":"Fact Description <code>ansible_memory_mb.real.total</code> Total RAM in MB <code>ansible_processor_count</code> Number of CPUs <code>ansible_processor_cores</code> Number of CPU cores"},{"location":"005-facts/#user-defined-facts","title":"User-defined Facts","text":"Fact Description <code>ansible_user</code> Current user <code>ansible_group</code> Current group"},{"location":"005-facts/#04-disabling-fact-gathering","title":"04. Disabling fact gathering","text":"<ul> <li>By default, Ansible gathers facts before running a playbook. </li> <li>In order to disable it, add the following at the beginning of your playbook:</li> <li>To disable fact gathering, set <code>gather_facts</code> to <code>no</code> in your playbook:</li> </ul> <pre><code>- hosts: all\n  gather_facts: no\n  tasks:\n    - name: Print a message\n      debug:\n        msg: \"Facts gathering is disabled!\"\n</code></pre>"},{"location":"005-facts/#05-custom-facts","title":"05. Custom Facts","text":"<ul> <li>You can define custom facts by creating <code>.fact</code> files, placing them inside <code>/etc/ansible/facts.d/</code> directory on the managed host.</li> </ul>"},{"location":"005-facts/#example-creating-a-custom-fact","title":"Example: Creating a custom fact","text":"<ul> <li> <p>Create the file <code>/etc/ansible/facts.d/custom.fact</code> with:</p> <pre><code>[custom]\nenvironment=production\napp_version=1.2.3\n</code></pre> </li> <li> <p>Retrieve the fact in a playbook:</p> <pre><code>- hosts: all\n  tasks:\n    - debug:\n        msg: \"App version is {{ ansible_local.custom.app_version }}\"\n</code></pre> </li> </ul>"},{"location":"005-facts/#using-custom-facts","title":"Using Custom Facts","text":"<ul> <li>Another way to define your own custom facts using the <code>set_fact</code> module in your playbooks.</li> <li> <p>Here is an example:</p> <pre><code>- hosts: all\n  tasks:\n    - name: Set custom fact\n      ansible.builtin.set_fact:\n        my_custom_fact: \"Hello, Ansible!\"\n    - name: Print custom fact\n      debug:\n        msg: \"{{ my_custom_fact }}\"\n</code></pre> </li> </ul>"},{"location":"005-facts/#06-hands-on","title":"06. Hands-on","text":"<ul> <li> <p>Use the <code>setup</code> module to gather and print all facts from <code>linux-server-1</code>.</p> <p> Solution <pre><code>ansible linux-server-1 -m setup\n</code></pre> <li> <p>Use the <code>setup</code> module to gather and print only the network-related facts from <code>linux-server-2</code>.</p> <p> Solution <p><pre><code>ansible linux-server-2 -m setup -a \"filter=ansible_default_ipv4*\"\n</code></pre> </p> <li> <p>Create a playbook that installs <code>nginx</code> only if the target host is running <code>Ubuntu</code>.</p> <p> Solution <pre><code>---\n- hosts: all\n  tasks:\n    - name: Install nginx on Ubuntu\n      ansible.builtin.apt:\n        name: nginx\n        state: present\n      when: ansible_distribution == \"Ubuntu\"\n</code></pre> <li> <p>Create a playbook that restarts a service only if the host has less than <code>4GB</code> of RAM.</p> <p> Solution <p><pre><code>---\n- hosts: all\n  tasks:\n    - name: Restart service if memory low\n      ansible.builtin.service:\n        name: my_service\n        state: restarted\n      when: ansible_memory_mb.real.total &lt; 4096\n</code></pre> </p> <li> <p>Create a custom fact that defines the environment as <code>development</code> and print it in a playbook.</p> <p> Solution <p>First, create <code>/etc/ansible/facts.d/custom.fact</code> on the host:</p> <pre><code>[custom]\nenvironment=development\n</code></pre> <p>Then playbook:</p> <p><pre><code>---\n- hosts: all\n  tasks:\n    - debug:\n        msg: \"Environment is {{ ansible_local.custom.environment }}\"\n</code></pre> </p> <li> <p>Create a playbook that sets a custom fact <code>deployment_stage</code> to <code>staging</code> and prints it.</p> <p> Solution <p><pre><code>---\n- hosts: all\n  tasks:\n    - name: Set custom fact\n      ansible.builtin.set_fact:\n        deployment_stage: staging\n    - name: Print custom fact\n      debug:\n        msg: \"Deployment stage: {{ deployment_stage }}\"\n</code></pre> </p> <li> <p>Disable fact gathering in a playbook and print a message indicating that facts are not gathered.</p> <p> Solution <pre><code>---\n- hosts: all\n  gather_facts: no\n  tasks:\n    - name: Print message\n      debug:\n        msg: \"Facts gathering is disabled!\"\n</code></pre> <li> <p>Create a playbook that prints the hostname of each target host using the appropriate fact.</p> <p> Solution <p><pre><code>---\n- hosts: all\n  tasks:\n    - name: Print hostname\n      debug:\n        msg: \"Hostname: {{ ansible_hostname }}\"\n</code></pre> </p> <li> <p>Create a playbook that checks the OS family and installs a package accordingly (e.g., <code>nginx</code> for <code>Debian</code>, <code>httpd</code> for <code>RedHat</code>).</p> <p> Solution <pre><code>---\n- hosts: all\n  tasks:\n    - name: Install nginx on Debian\n      ansible.builtin.apt:\n        name: nginx\n        state: present\n      when: ansible_os_family == \"Debian\"\n    - name: Install httpd on RedHat\n      ansible.builtin.dnf:\n        name: httpd\n        state: present\n      when: ansible_os_family == \"RedHat\"\n</code></pre> <li> <p>Create a playbook that gathers facts and prints the total memory of each host.</p> <p> Solution <p><pre><code>---\n- hosts: all\n  tasks:\n    - name: Print total memory\n      debug:\n        msg: \"Total memory: {{ ansible_memory_mb.real.total }} MB\"\n</code></pre> </p> <li> <p>Create a playbook that checks the default gateway and prints it.</p> <p> Solution <p><pre><code>---\n- hosts: all\n  tasks:\n    - name: Print default gateway\n      debug:\n        msg: \"Default gateway: {{ ansible_default_ipv4.gateway }}\"\n</code></pre> </p> <li> <p>Create a playbook that sets a custom fact <code>backup_required</code> to <code>yes</code> and prints a message if backup is required.</p> <p> Solution <p><pre><code>---\n- hosts: all\n  tasks:\n    - name: Set custom fact\n      ansible.builtin.set_fact:\n        backup_required: yes\n    - name: Print message if backup required\n      debug:\n        msg: \"Backup is required\"\n      when: backup_required == \"yes\"\n</code></pre> </p> <li> <p>Create a playbook that uses the <code>ansible_user</code> fact to print the current user on each host.</p> <p> Solution <pre><code>---\n- hosts: all\n  tasks:\n    - name: Print current user\n      debug:\n        msg: \"Current user: {{ ansible_user }}\"\n</code></pre> <li> <p>Print the IP addresses of all the machines.</p> <p> Solution <p><pre><code>ansible all -m setup -a \"filter=ansible_default_ipv4.address\"\n</code></pre> </p> <li> <p>Bonus - Try printing the address of <code>linux-server-2</code> only, without modifying the inventory file.</p> <p> Solution <pre><code>ansible linux-server-2 -m setup -a \"filter=ansible_default_ipv4.address\"\n</code></pre>"},{"location":"005-facts/#07-summary","title":"07. Summary","text":"<p>\ud83d\udd39 Ansible facts provide system details dynamically. \ud83d\udd39 They are automatically gathered using the <code>setup</code> module. \ud83d\udd39 They are useful for conditional logic in playbooks. \ud83d\udd39 Facts may include OS, networking, CPU, memory and more. \ud83d\udd39 Custom facts can be created for customized automation.</p>"},{"location":"006-git/","title":"006 Git","text":""},{"location":"006-git/#lab-006-git-integration-with-ansible","title":"Lab 006 - Git Integration with Ansible","text":"<ul> <li>In this section, we will cover Git integration with Ansible.</li> <li>We will learn how to automate Git operations on remote servers using Ansible playbooks.</li> <li>This is useful for deploying code, managing repositories, and keeping your infrastructure up to date.</li> </ul>"},{"location":"006-git/#01-git-module-basics","title":"01. Git Module Basics","text":"<ul> <li>Ansible provides the <code>ansible.builtin.git</code> module to manage Git repositories on remote hosts.</li> <li>The module supports cloning, pulling, checking out branches/tags, and more.</li> <li> <p>Key parameters:</p> Parameter Description <code>repo</code> URL of the Git repository <code>dest</code> Destination path on the remote host <code>version</code> Branch, tag, or commit to checkout (default: HEAD) <code>force</code> Force checkout/update even if working directory is dirty <code>update</code> Pull latest changes if repository already exists (default: yes) <code>clone</code> Perform clone operation (default: yes) <ul> <li>For more details, refer to the Ansible Git module documentation.</li> </ul> </li> </ul>"},{"location":"006-git/#ansible-git-ansiblebuiltingit-examples","title":"Ansible Git <code>ansible.builtin.git</code> examples:","text":""},{"location":"006-git/#02-cloning-repositories","title":"02. Cloning Repositories","text":"<ul> <li>Use the <code>git</code> module to clone a repository to a remote server.</li> <li>Specify the <code>repo</code> and <code>dest</code> parameters.</li> <li>If the repository already exists at the destination, it will not be cloned again unless <code>force</code> is set to <code>yes</code>.</li> <li>By default, the latest commit from the default branch is checked out.</li> <li> <p>Here is an example playbook that clones a public Git repository:</p> <pre><code>---\n- hosts: all\n  tasks:\n    - name: Clone a public Git repository\n      ansible.builtin.git:\n        repo: 'https://github.com/octocat/Hello-World.git'\n        dest: /opt/hello-world\n</code></pre> </li> <li> <p>Example: Cloning with Specific Branch</p> <pre><code>---\n- hosts: all\n  tasks:\n    - name: Clone repository and checkout specific branch\n      ansible.builtin.git:\n        repo: 'https://github.com/example/repo.git'\n        dest: /opt/myapp\n        version: develop\n</code></pre> </li> </ul>"},{"location":"006-git/#03-updating-repositories","title":"03. Updating Repositories","text":"<ul> <li>The <code>git</code> module automatically pulls changes if the repository exists and <code>update</code> is true.</li> <li>Use <code>force: yes</code> to overwrite local changes.</li> </ul>"},{"location":"006-git/#example-pull-latest-changes","title":"Example: Pull Latest Changes","text":"<pre><code>---\n- hosts: all\n  tasks:\n    - name: Update repository to latest commit\n      ansible.builtin.git:\n        repo: 'https://github.com/example/repo.git'\n        dest: /opt/myapp\n        update: yes\n        force: yes\n</code></pre>"},{"location":"006-git/#04-working-with-branches-and-tags","title":"04. Working with Branches and Tags","text":"<ul> <li>Use the <code>version</code> parameter to checkout specific branches, tags, or commits.</li> </ul>"},{"location":"006-git/#example-checkout-a-tag","title":"Example: Checkout a Tag","text":"<pre><code>---\n- hosts: all\n  tasks:\n    - name: Checkout specific tag\n      ansible.builtin.git:\n        repo: 'https://github.com/example/repo.git'\n        dest: /opt/myapp\n        version: v1.0.0\n</code></pre>"},{"location":"006-git/#example-switch-branches","title":"Example: Switch Branches","text":"<pre><code>---\n- hosts: all\n  tasks:\n    - name: Switch to main branch\n      ansible.builtin.git:\n        repo: 'https://github.com/example/repo.git'\n        dest: /opt/myapp\n        version: main\n</code></pre>"},{"location":"006-git/#05-authentication-and-ssh","title":"05. Authentication and SSH","text":"<ul> <li>For private repositories, use SSH keys or HTTPS with credentials.</li> <li>Ensure SSH keys are properly configured on the Ansible controller and remote hosts.</li> </ul>"},{"location":"006-git/#example-using-ssh-key","title":"Example: Using SSH Key","text":"<pre><code>---\n- hosts: all\n  tasks:\n    - name: Clone private repo using SSH\n      ansible.builtin.git:\n        repo: 'git@github.com:example/private-repo.git'\n        dest: /opt/private-app\n        key_file: /home/ansible/.ssh/id_rsa\n</code></pre>"},{"location":"006-git/#example-using-https-with-token","title":"Example: Using HTTPS with Token","text":"<pre><code>---\n- hosts: all\n  vars:\n    git_token: \"{{ lookup('env', 'GIT_TOKEN') }}\"\n  tasks:\n    - name: Clone with HTTPS authentication\n      ansible.builtin.git:\n        repo: \"https://{{ git_token }}@github.com/example/repo.git\"\n        dest: /opt/myapp\n</code></pre>"},{"location":"006-git/#06-common-patterns-and-best-practices","title":"06. Common Patterns and Best Practices","text":"<ul> <li>Always use absolute paths for <code>dest</code>.</li> <li>Handle idempotency by letting the module manage updates.</li> <li>Use <code>force: yes</code> carefully as it can overwrite changes.</li> <li>Store sensitive information like tokens in Ansible Vault.</li> </ul>"},{"location":"006-git/#example-idempotent-deployment","title":"Example: Idempotent Deployment","text":"<pre><code>---\n- hosts: all\n  tasks:\n    - name: Ensure application is at latest version\n      ansible.builtin.git:\n        repo: 'https://github.com/example/app.git'\n        dest: /opt/myapp\n        version: main\n      register: git_result\n\n    - name: Restart service if code changed\n      ansible.builtin.service:\n        name: myapp\n        state: restarted\n      when: git_result.changed\n</code></pre>"},{"location":"006-git/#07-hands-on","title":"07. Hands-on","text":"<ul> <li> <p>Clone a public Git repository to <code>/opt/hello-world</code> on your target servers.</p> <p> Solution <pre><code>---\n- hosts: all\n  tasks:\n    - name: Clone Hello World repository\n      ansible.builtin.git:\n        repo: 'https://github.com/octocat/Hello-World.git'\n        dest: /opt/hello-world\n</code></pre> <li> <p>Create a playbook that clones a repository and checks out a specific branch called <code>develop</code>.</p> <p> Solution <pre><code>---\n- hosts: all\n  tasks:\n    - name: Clone and checkout develop branch\n      ansible.builtin.git:\n        repo: 'https://github.com/example/repo.git'\n        dest: /opt/myapp\n        version: develop\n</code></pre> <li> <p>Write a playbook that updates an existing repository to the latest commit on the main branch.</p> <p> Solution <pre><code>---\n- hosts: all\n  tasks:\n    - name: Update repository to latest main\n      ansible.builtin.git:\n        repo: 'https://github.com/example/repo.git'\n        dest: /opt/myapp\n        version: main\n        update: yes\n</code></pre> <li> <p>Create a playbook that checks out a specific tag (e.g., <code>v1.0.0</code>) from a repository.</p> <p> Solution <pre><code>---\n- hosts: all\n  tasks:\n    - name: Checkout specific tag\n      ansible.builtin.git:\n        repo: 'https://github.com/example/repo.git'\n        dest: /opt/myapp\n        version: v1.0.0\n</code></pre> <li> <p>Modify a playbook to force update a repository, overwriting any local changes.</p> <p> Solution <pre><code>---\n- hosts: all\n  tasks:\n    - name: Force update repository\n      ansible.builtin.git:\n        repo: 'https://github.com/example/repo.git'\n        dest: /opt/myapp\n        force: yes\n</code></pre> <li> <p>Create a playbook that clones a repository and restarts a service if the code was updated.</p> <p> Solution <pre><code>---\n- hosts: all\n  tasks:\n    - name: Deploy application\n      ansible.builtin.git:\n        repo: 'https://github.com/example/app.git'\n        dest: /opt/myapp\n      register: git_deploy\n\n    - name: Restart service if changed\n      ansible.builtin.service:\n        name: myapp\n        state: restarted\n      when: git_deploy.changed\n</code></pre> <li> <p>Set up SSH key authentication for cloning a private repository.</p> <p> Solution <p>First, ensure SSH key is copied to the remote host:</p> <pre><code>---\n- hosts: all\n  tasks:\n    - name: Copy SSH private key\n      ansible.builtin.copy:\n        src: ~/.ssh/id_rsa\n        dest: /home/ansible/.ssh/id_rsa\n        mode: '0600'\n\n    - name: Clone private repository\n      ansible.builtin.git:\n        repo: 'git@github.com:example/private-repo.git'\n        dest: /opt/private-app\n        key_file: /home/ansible/.ssh/id_rsa\n</code></pre>"},{"location":"006-git/#08-summary","title":"08. Summary","text":"<p>\ud83d\udd39 Use <code>ansible.builtin.git</code> module for Git operations in playbooks. \ud83d\udd39 Supports cloning, pulling, and checking out branches/tags. \ud83d\udd39 Ensure proper authentication for private repositories. \ud83d\udd39 Leverage idempotency for safe repeated runs. \ud83d\udd39 Combine with other modules for complete deployment workflows.</p>"},{"location":"007-create-user/","title":"007 Create User","text":""},{"location":"007-create-user/#lab-007-create-user-with-ansible","title":"Lab 007 - Create user with Ansible","text":"<ul> <li>In this section we will understand how to use the <code>Create User Playbook</code>.</li> <li>We will have hands-on experience in writing it ourselves using a sample playbook.</li> <li>We will review the playbook\u2019s <code>vars</code>, <code>become</code>, <code>changed_when</code> sections.</li> <li>We will edit the script to create another user with different name and password.</li> </ul>"},{"location":"007-create-user/#01-ansibles-user-module","title":"01. Ansible\u2019s <code>user</code> module","text":"<ul> <li>Ansible\u2019s <code>user</code> module is a powerful tool for managing user accounts on remote systems. It allows you to create, update, and remove users, set passwords, manage groups, and configure SSH keys. This is essential in automating system administration tasks.</li> <li>See the Ansible <code>user module</code> documentation.</li> </ul>"},{"location":"007-create-user/#02-create-a-user","title":"02. Create a user","text":"<ul> <li>See the below basic example for creating a user named <code>username</code> with a hashed password, adding them to the <code>wheel</code> group, and generating an SSH key.</li> </ul> <pre><code>- name: Create a new user\n  ansible.builtin.user:\n    name: \"username\"\n    password: \"{{ 'password' | password_hash('sha512') }}\"\n    groups: \"wheel\"\n    shell: /bin/bash\n    state: present\n    create_home: true\n    generate_ssh_key: true\n</code></pre> <ul> <li>See the below advanced example, including <code>custom home</code>, <code>expiry</code>, and <code>comment</code></li> </ul> <pre><code>- name: Create a user with custom options\n  ansible.builtin.user:\n    name: \"devops\"\n    comment: \"DevOps Engineer\"\n    home: \"/opt/devops\"\n    expires: 1751328000  # Unix timestamp for expiry\n    password: \"{{ 'SuperSecret123' | password_hash('sha512') }}\"\n    groups: \"sudo\"\n    shell: /bin/zsh\n    state: present\n    create_home: true\n</code></pre>"},{"location":"007-create-user/#03-password-management","title":"03. Password management","text":"<ul> <li>Always hash passwords using the <code>password_hash</code> filter for security.</li> <li>Example:   <pre><code>password: \"{{ 'mysecret' | password_hash('sha512') }}\"\n</code></pre></li> <li>You can generate a hash in Python:   <pre><code>import crypt\nprint(crypt.crypt('mysecret', crypt.mksalt(crypt.METHOD_SHA512)))\n</code></pre></li> <li>See the <code>password hash</code> in Ansible documentation.</li> </ul>"},{"location":"007-create-user/#04-ssh-key-setup","title":"04. SSH key setup","text":"<ul> <li>Use <code>generate_ssh_key: true</code> to automatically create an SSH key for the user.</li> <li>You can specify key type and file:   <pre><code>generate_ssh_key: true\nssh_key_type: rsa\nssh_key_bits: 4096\nssh_key_file: .ssh/id_rsa\n</code></pre></li> </ul>"},{"location":"007-create-user/#05-troubleshooting-verification","title":"05. Troubleshooting &amp; verification","text":"<ul> <li>Use the <code>command</code> module to verify user creation:   <pre><code>- name: Verify user\n  ansible.builtin.command: \"id username\"\n  register: user_info\n  changed_when: false\n  failed_when: user_info.rc != 0\n</code></pre></li> <li>See <code>/etc/passwd</code> and <code>/etc/group</code> for user and group info.</li> </ul>"},{"location":"007-create-user/#06-best-practices","title":"06. Best practices","text":"<ul> <li>Use <code>become: true</code> for privilege escalation.</li> <li>Use variables for usernames and passwords to avoid hardcoding.</li> <li>Document your playbooks for clarity.</li> <li>Clean up users with <code>state: absent</code> when needed.</li> </ul>"},{"location":"008-challenges/","title":"008 Challenges","text":""},{"location":"008-challenges/#lab-008-challenges","title":"Lab 008 - Challenges","text":""},{"location":"008-challenges/#01-task-01","title":"01. Task 01:","text":"<p>1\ufe0f\u20e3 Create a user named <code>&lt;hostname&gt;</code> for each machine.</p> <p>2\ufe0f\u20e3 Verify that the user was created.</p> <p>3\ufe0f\u20e3 Create an ansible inventory with the username in the configuration, using the format below:   <pre><code>&lt;hostname&gt;    ansible_host=&lt;hostname&gt; ansible_ssh_user=&lt;user&gt;\n</code></pre></p>"},{"location":"008-challenges/#02-task-02","title":"02. Task 02:","text":"<p>1\ufe0f\u20e3 Clone a <code>git</code> repository from your GitHub or GitLab account.</p> <p>2\ufe0f\u20e3 Commit changes to the repository.</p> <p>3\ufe0f\u20e3 Push the changes to the repository.</p>"},{"location":"009-roles/","title":"009 Roles","text":""},{"location":"009-roles/#lab-009-roles","title":"Lab 009 - Roles","text":""},{"location":"009-roles/#01-what-are-ansible-roles","title":"01. What are Ansible roles?","text":"<ul> <li>Roles let you automatically load related <code>vars</code>, <code>files</code>, <code>tasks</code>, <code>handlers</code>, and other Ansible artifacts based on a known file structure. </li> <li>After you group your content into roles, you can easily reuse them and share them with other users.</li> <li>By default, Ansible will look in each directory within a role for the file names <code>main</code>/<code>main.yml</code>/<code>main.yaml</code>.</li> </ul>"},{"location":"009-roles/#02-ansible-roles-file-structure","title":"02. Ansible roles file structure","text":"Files Description tasks the main list of tasks that the role executes handlers handlers, which may be used within or outside this role library modules, which may be used within this role (see Embedding modules and plugins in roles for more information) defaults default variables for the role (see Using Variables for more information) these variables have the lowest priority of any variables available and can be easily overridden by any other variable, including <code>inventory variables</code> vars other variables for the role (see Using Variables for more information) files files that the role deploys templates templates that the role deploys meta metadata for the role, including role dependencies and optional Galaxy metadata, such as supported platforms"},{"location":"009-roles/#03-building-an-ansible-role","title":"03. Building an Ansible role","text":"<ul> <li>In this demo we will create a role for deploying a <code>nodeJS</code> app.</li> <li>The app will be deployed from a pre-defined code.</li> <li>Each server will be deployed with its own configuration (values).</li> <li>We will also deploy some other files for learning purposes.</li> </ul>"},{"location":"009-roles/#04-initialize-file-structure","title":"04. Initialize file structure","text":"<p><pre><code># Lets create the roles file structure\nansible-galaxy init codewizard_lab_role\n</code></pre>  - The file system of the role will look like:</p> <p> </p>"},{"location":"009-roles/#05-create-the-role-content","title":"05. Create the role content","text":"<pre><code>---\n### defaults/main.yml\n###\n### This file contains the variables for the Demo lab\n###\n\n# Defaults file for codewizard_lab_role\nmotd_message: \"Welcome to Ansible Roles Lab\"\n\n### The packages we wish to install on the servers\napt_packages:\n  - python3\n  - nodejs\n  - npm\n\n# Packages to verify that they were installed\napt_packages_verify:\n  - python3\n  - npm\n\npackage_state: latest\n</code></pre> <p>\u2013 templates/motd.j2   <pre><code>### templates/motd.j2\n\n_____             _          _    _  _                      _ \n/  __ \\           | |        | |  | |(_)                    | |\n| /  \\/  ___    __| |  ___   | |  | | _  ____ __ _  _ __  __| |\n| |     / _ \\  / _` | / _ \\  | |/\\| || ||_  // _` || '__|/ _` |\n| \\__/\\| (_) || (_| ||  __/  \\  /\\  /| | / /| (_| || |  | (_| |\n\\____/ \\___/  \\__,_| \\___|   \\/  \\/ |_|/___|\\__,_||_|   \\__,_|\n\n{{ motd_message }}\n\nSystem information:\n-------------------\n\nOS:         {{ ansible_distribution }} {{ ansible_distribution_version }}\nHostname:   {{ inventory_hostname }}\n\n{{ custom_message | default('') }}\n</code></pre></p> <p></p> <p>\u2013 templates/node-server.j2   <pre><code>### templates/node-server.j2\nconst\n    // Set the server port which will be listening to\n    // Those 2 values are passed from the env file\n    SERVER_PORT = 5000,\n    SERVER_NAME = \"{{ inventory_hostname }}\";\n\n// Create the basic http server\nrequire('http')\n    .createServer((request, response) =&gt; {\n\n        // Send reply to user\n        response.end(`&lt;h1&gt;Hello from ${SERVER_NAME}.&lt;/h1&gt;`);\n\n    }).listen(SERVER_PORT, () =&gt; {\n        // Notify users that the server is up and running\n        console.log(`${SERVER_NAME} is up. \n            Please click or point your browser to:\n            http://localhost:${SERVER_PORT}`);\n    });\n</code></pre></p> <ul> <li> <p>In this example we will have multiple tasks for learning purposes.</p> </li> <li>We will need to create the tasks for each role.</li> <li>Once the tasks are ready, we can define them in the main task file.</li> </ul> <p>\u2014 tasks/pre-requirements.yaml   <pre><code>### tasks/pre-requirements.yaml\n---\n- name: Install Packages\n  ansible.builtin.apt:\n    name: \"{{ item }}\"\n    state: \"{{ package_state }}\"\n  # Loop over the required packages to install\n  with_items: \"{{ apt_packages }}\"\n\n- name: Verify Packages Installation\n  ansible.builtin.command: \"{{ item }} --version\"\n  register: packages_version\n  with_items: \"{{ apt_packages_verify }}\"\n\n- name: Print package version\n  ansible.builtin.debug:\n    msg: \"{{ item.stdout_lines  }}\"\n  with_items: \"{{ packages_version.results }}\"\n</code></pre></p> <p>\u2014 tasks/node-server.yaml</p> <pre><code>  ### tasks/node-server.yaml\n  ---\n  - name: Copy Node server\n    ansible.builtin.template:\n      src: templates/node-server.j2\n      dest: /node-server.js\n      mode: 600\n    become: true\n    become_method: ansible.builtin.su\n\n  - name: Install \"pm2\" node.js package.\n    community.general.npm:\n      name: \"pm2\"\n      global: true\n    become: true\n    become_method: ansible.builtin.su\n\n  - name: Get running node processes\n    shell: \"ps -ef | grep -v grep | grep -w node | awk '{print $2}'\"\n    register: running_processes\n\n  - name: Kill running node server (if any)\n    shell: \"kill {{ item }}\"\n    with_items: \"{{ running_processes.stdout_lines }}\"\n\n  - name: Wait for the process to die\n    wait_for:\n      path: \"/proc/{{ item }}/status\"\n      state: absent\n    with_items: \"{{ running_processes.stdout_lines }}\"\n    ignore_errors: true\n    register: killed_processes\n\n  - name: Force kill stuck processes\n    shell: \"kill -9 {{ item }}\"\n    with_items: \"{{ killed_processes.results | select('failed') | map(attribute='item') | list }}\"\n\n  - name: Start Node server\n    ansible.builtin.command:\n      chdir: /\n      cmd: \"pm2 start -f /node-server.js\"\n    register: server_status\n    changed_when: server_status.rc != 0\n\n  - name: Print server status\n    ansible.builtin.debug:\n      msg: \"{{ server_status.stdout_lines }}\"\n    when: server_status.rc == 0\n\n  - name: Check server\n    uri:\n      url: http://localhost:5000\n      method: GET\n      status_code: 200\n    register: server_status\n\n  - name: Print server status\n    ansible.builtin.debug:\n      msg: \"{{ server_status.status }} - {{ server_status.msg }}\"\n</code></pre> <p>\u2014 tasks/motd.yaml   <pre><code>  ### tasks/motd.j2\n  ---\n  - name: Copy template\n    ansible.builtin.template:\n      src: templates/motd.j2\n      dest: /etc/motd\n      mode: preserve\n    become: true\n    become_method: ansible.builtin.su\n</code></pre></p> <p>\u2014 tasks/main.yml</p> <pre><code>  ### tasks/main.yml\n  ---\n  - name: Include Pre-Requirements task\n    ansible.builtin.include_tasks:\n      file: pre-requirements.yaml\n\n  - name: Include motd task\n    ansible.builtin.include_tasks:\n      file: motd.yaml\n\n  - name: Deploy node server\n    ansible.builtin.include_tasks:\n      file: node-server.yaml\n</code></pre> <p></p> <ul> <li> </li> </ul> <pre><code>### 009-role-playbook.yml\n---\n###\n### The playbook for using our role\n### \n- name: Executing codewizard_lab_role\n  hosts: all\n  become: true\n  become_method: ansible.builtin.su\n\n  roles:\n    - codewizard_lab_role  \n</code></pre>"},{"location":"009-roles/#create-the-defaultsmainyml","title":"Create the <code>defaults/main.yml</code>","text":""},{"location":"009-roles/#create-the-templates","title":"Create the templates","text":""},{"location":"009-roles/#create-the-tasks-for-the-role","title":"Create the tasks for the role","text":""},{"location":"009-roles/#create-the-playbook-for-the-role","title":"Create the playbook for the role","text":""},{"location":"010-loops-and-conditionals/","title":"010 Loops And Conditionals","text":""},{"location":"010-loops-and-conditionals/#lab-010-loops-and-conditionals-in-ansible","title":"Lab 010 - Loops and Conditionals in Ansible","text":"<ul> <li>In this section, we will cover Loops and Conditionals in Ansible.</li> <li>Loops assist in efficiently performing repetitive tasks.</li> <li>Conditions allow tasks to be executed based on specific criteria.</li> <li>See documentation about Loops and Conditionals in Ansible.</li> </ul>"},{"location":"010-loops-and-conditionals/#01-ansible-loops","title":"01. Ansible Loops","text":""},{"location":"010-loops-and-conditionals/#basic-loop","title":"Basic loop","text":"<ul> <li>Ansible provides a <code>loop</code> keyword to execute tasks multiple times with different inputs:</li> </ul> <p><pre><code>---\n- hosts: localhost\n  tasks:\n    - name: Install multiple packages\n      apt:\n        name: \"{{ item }}\"\n        state: present\n      loop:\n        - git\n        - curl\n        - vim\n</code></pre> </p>"},{"location":"010-loops-and-conditionals/#loop-with-dictionaries","title":"Loop with dictionaries","text":"<ul> <li>Loops can be used with dictionaries to process structured data:</li> </ul> <p><pre><code>---\n- hosts: localhost\n  tasks:\n    - name: Add multiple users\n      user:\n        name: \"{{ item.name }}\"\n        shell: \"{{ item.shell }}\"\n      loop:\n        - { name: \"alice\", shell: \"/bin/bash\" }\n        - { name: \"bob\", shell: \"/bin/zsh\" }\n</code></pre> </p>"},{"location":"010-loops-and-conditionals/#nested-loops","title":"Nested loops","text":"<ul> <li>Nested loops allow iterating over multiple lists:</li> </ul> <pre><code>---\n- hosts: localhost\n  tasks:\n    - name: Assign permissions\n      file:\n        path: \"/home/{{ item.0 }}/{{ item.1 }}\"\n        state: touch\n        owner: \"{{ item.0 }}\"\n      loop:\n        - [\"alice\", \"bob\"]\n        - [\"file1.txt\", \"file2.txt\"]\n      loop_control:\n        loop_var: item\n</code></pre>"},{"location":"010-loops-and-conditionals/#02-ansible-conditionals","title":"02. Ansible Conditionals","text":""},{"location":"010-loops-and-conditionals/#using-the-when-clause","title":"Using the <code>when</code> clause","text":"<ul> <li>Conditionals can be defined using the <code>when</code> clause:</li> </ul> <p><pre><code>---\n- hosts: localhost\n  tasks:\n    - name: Install Apache only on Ubuntu\n      apt:\n        name: apache2\n        state: present\n      when: ansible_os_family == \"Debian\"\n</code></pre> </p>"},{"location":"010-loops-and-conditionals/#complex-conditionals","title":"Complex conditionals","text":"<ul> <li>Multiple conditionals can be combined with <code>and</code>, <code>or</code>, and <code>not</code> clauses:</li> </ul> <pre><code>---\n- hosts: localhost\n  tasks:\n    - name: Restart service only if running\n      service:\n        name: nginx\n        state: restarted\n      when: ansible_os_family == \"RedHat\" and ansible_distribution_major_version | int &gt;= 7\n</code></pre>"},{"location":"010-loops-and-conditionals/#03-combining-loops-and-conditionals","title":"03. Combining loops and conditionals","text":"<ul> <li>Loops and conditionals can be used together:</li> </ul> <pre><code>---\n- hosts: localhost\n  tasks:\n    - name: Create users only if home directory does not exist\n      user:\n        name: \"{{ item }}\"\n        state: present\n      loop:\n        - alice\n        - bob\n      when: not ansible_facts['getent_passwd'][item] is defined\n</code></pre>"},{"location":"010-loops-and-conditionals/#04-hands-on","title":"04. Hands-on","text":"<ul> <li>Try writing a playbook that installs different packages based on the OS family.</li> <li>Try to use as many parts as you can (external vars, vars, loops, conditions etc) while doing so.</li> </ul>"},{"location":"011-jinja-templating/","title":"011 Jinja Templating","text":""},{"location":"011-jinja-templating/#lab-011-jinja2-templating","title":"Lab 011 - <code>Jinja2</code> Templating","text":"<ul> <li>During our day to day job, we come across dozens of configuration files, set in many different formats.</li> <li>What happens if we need to configure different environments, each with its own values? Should we duplicate the same file for each one?</li> <li>This is where <code>Jinja2</code> templates come to the rescue! <code>Jinja2</code> helps us template our configuration files to be used with different values and reduce duplications.</li> <li><code>Jinja2</code> is a powerful templating engine integrated into Ansible, used commonly in python projects.</li> <li>Templates allow dynamic configuration file generation, based on variables and facts.</li> <li><code>Jinja2</code> can be used with conditionals and loops and can even perform filters and functions on our values!</li> </ul>"},{"location":"011-jinja-templating/#01-creating-jinja2-templates","title":"01. Creating Jinja2 templates","text":"<ul> <li>Create a <code>Jinja2</code> template file by appending a <code>.j2</code> suffix to our base config filename. For example, <code>nginx.conf.j2</code>:</li> </ul> <pre><code># Example\n\nevents {}\nhttp {\n  server {\n    listen {{ web_port }};\n    server_name {{ domain_name }};\n\n    location / {\n      proxy_pass http://{{ backend_ip }}:{{ backend_port }};\n    }\n  }\n}\n</code></pre>"},{"location":"011-jinja-templating/#02-using-templates-in-playbooks","title":"02. Using templates in playbooks","text":"<ul> <li>Integrate <code>Jinja2</code> templates using the <code>ansible.builtin.template</code> module:</li> </ul> <pre><code>---\n- hosts: web_servers\n  vars:\n    web_port: 80\n    domain_name: example.com\n    backend_ip: 192.168.10.10\n    backend_port: 8080\n  tasks:\n    - name: Deploy Nginx Configuration\n      ansible.builtin.template:\n        src: config.j2\n        dest: /etc/nginx/conf.d/site.conf\n      notify: Restart Nginx\n\n  handlers:\n    - name: Restart Nginx\n      ansible.builtin.service:\n        name: nginx\n        state: restarted\n</code></pre>"},{"location":"011-jinja-templating/#03-using-conditional-statements","title":"03. Using conditional statements","text":"<ul> <li><code>jinja2</code> supports conditional logic to dynamically alter configurations:</li> </ul> <pre><code>{% if ansible_distribution == 'Ubuntu' %}\nUser ubuntu;\n{% elif ansible_distribution == 'CentOS' %}\nUser centos;\n{% else %}\nUser default;\n{% endif %}\n</code></pre>"},{"location":"011-jinja-templating/#04-looping-with-jinja2","title":"04. Looping with <code>Jinja2</code>","text":"<ul> <li><code>Jinja2</code> makes it easy to iterate over lists or dictionaries:</li> </ul> <pre><code># hosts file\n{% for host in groups['web_servers'] %}\n{{ hostvars[host]['ansible_default_ipv4']['address'] }} {{ host }}\n{% endfor %}\n</code></pre>"},{"location":"011-jinja-templating/#05-filters-and-functions","title":"05. Filters and functions","text":"<ul> <li><code>Jinja2</code> includes built-in filters to transform data:</li> </ul> <pre><code># Convert text to uppercase\nServerName {{ domain_name | upper }}\n\n# Default filter for fallback values\nListen {{ custom_port | default(8080) }}\n</code></pre>"},{"location":"011-jinja-templating/#06-summary","title":"06. Summary","text":"<p>\ud83d\udd39 <code>Jinja2</code> enables dynamic template generation with variables and facts. \ud83d\udd39 Templates help manage complex configurations in a more simple and efficient manner. \ud83d\udd39 Use conditional statements and loops for highly dynamic setups. \ud83d\udd39 Built-in filters enhance the manipulation of data directly within templates.</p> <p> </p>"},{"location":"011-jinja-templating/#07-hands-on","title":"07. Hands-on","text":"<ul> <li>Create a <code>Jinja2</code> template for generating a dynamic <code>/etc/motd</code> (\u201cMessage of the Day\u201d) file, containing a personal message (ensure first that it is enabled).</li> <li>The relevant code can be found in lab 009.</li> <li>Bonus: Use facts to display useful information about OS distribution, IP address and current hostname dynamically when logging in.</li> </ul>"}]}